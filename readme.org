* Completion system
** Vertico
#+begin_src emacs-lisp
(use-package vertico
  :custom (vertico-cycle t)
  :init (vertico-mode))

(use-package savehist
  :init (savehist-mode))

;; A few more useful configurations...
(use-package emacs
  :init
  ;; Add prompt indicator to `completing-read-multiple'.
  ;; Alternatively try `consult-completing-read-multiple'.
  (defun crm-indicator (args)
    (cons (concat "[CRM] " (car args)) (cdr args)))
  (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

  ;; Do not allow the cursor in the minibuffer prompt
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

  ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
  ;; Vertico commands are hidden in normal buffers.
  (setq read-extended-command-predicate
        #'command-completion-default-include-p)

  ;; Enable recursive minibuffers
  (setq enable-recursive-minibuffers t))
#+end_src
*** Orderless
https://github.com/minad/consult/wiki#minads-orderless-configuration
#+begin_src emacs-lisp
(use-package orderless
  :demand t
  :config
  (defvar +orderless-dispatch-alist
    '((?% . char-fold-to-regexp)
      (?! . orderless-without-literal)
      (?`. orderless-initialism)
      (?= . orderless-literal)
      (?~ . orderless-flex)))

  ;; Recognizes the following patterns:
  ;; * ~flex flex~
  ;; * =literal literal=
  ;; * %char-fold char-fold%
  ;; * `initialism initialism`
  ;; * !without-literal without-literal!
  ;; * .ext (file extension)
  ;; * regexp$ (regexp matching at end)
  (defun +orderless-dispatch (pattern index _total)
    (cond
     ;; Ensure that $ works with Consult commands, which add disambiguation suffixes
     ((string-suffix-p "$" pattern)
      `(orderless-regexp . ,(concat (substring pattern 0 -1) "[\x100000-\x10FFFD]*$")))
     ;; File extensions
     ((and
       ;; Completing filename or eshell
       (or minibuffer-completing-file-name
           (derived-mode-p 'eshell-mode))
       ;; File extension
       (string-match-p "\\`\\.." pattern))
      `(orderless-regexp . ,(concat "\\." (substring pattern 1) "[\x100000-\x10FFFD]*$")))
     ;; Ignore single !
     ((string= "!" pattern) `(orderless-literal . ""))
     ;; Prefix and suffix
     ((if-let (x (assq (aref pattern 0) +orderless-dispatch-alist))
          (cons (cdr x) (substring pattern 1))
        (when-let (x (assq (aref pattern (1- (length pattern))) +orderless-dispatch-alist))
          (cons (cdr x) (substring pattern 0 -1)))))))

  ;; Define orderless style with initialism by default
  (orderless-define-completion-style +orderless-with-initialism
    (orderless-matching-styles '(orderless-initialism orderless-literal orderless-regexp)))

  ;; You may want to combine the `orderless` style with `substring` and/or `basic`.
  ;; There are many details to consider, but the following configurations all work well.
  ;; Personally I (@minad) use option 3 currently. Also note that you may want to configure
  ;; special styles for special completion categories, e.g., partial-completion for files.
  ;;
  ;; 1. (setq completion-styles '(orderless))
  ;; This configuration results in a very coherent completion experience,
  ;; since orderless is used always and exclusively. But it may not work
  ;; in all scenarios. Prefix expansion with TAB is not possible.
  ;;
  ;; 2. (setq completion-styles '(substring orderless))
  ;; By trying substring before orderless, TAB expansion is possible.
  ;; The downside is that you can observe the switch from substring to orderless
  ;; during completion, less coherent.
  ;;
  ;; 3. (setq completion-styles '(orderless basic))
  ;; Certain dynamic completion tables (completion-table-dynamic)
  ;; do not work properly with orderless. One can add basic as a fallback.
  ;; Basic will only be used when orderless fails, which happens only for
  ;; these special tables.
  ;;
  ;; 4. (setq completion-styles '(substring orderless basic))
  ;; Combine substring, orderless and basic.
  ;;
  (setq completion-styles '(orderless)
        completion-category-defaults nil
        ;;; Enable partial-completion for files.
        ;;; Either give orderless precedence or partial-completion.
        ;;; Note that completion-category-overrides is not really an override,
        ;;; but rather prepended to the default completion-styles.
        ;; completion-category-overrides '((file (styles orderless partial-completion))) ;; orderless is tried first
        completion-category-overrides '((file (styles partial-completion)) ;; partial-completion is tried first
                                        ;; enable initialism by default for symbols
                                        (command (styles +orderless-with-initialism))
                                        (variable (styles +orderless-with-initialism))
                                        (symbol (styles +orderless-with-initialism)))
        orderless-component-separator #'orderless-escapable-split-on-space ;; allow escaping space with backslash!
        orderless-style-dispatchers '(+orderless-dispatch)))
#+end_src
** Company
#+begin_src emacs-lisp
(use-package company
  :commands company-abort
  :init (global-company-mode 1)
  :config
  (custom-set-faces
   '(company-tooltip-common
     ((t (:inhirit company-tooltip :weight bold :underline nil))))
   '(company-tooltip-common-selection
     ((t (:inhirit company-tooltip-selection :weight bold :underline nil)))))
  :custom ((company-tooltip-align-annotations t)
           (company-tooltip-limit 15)
           (company-idle-delay 0.0)
           (company-echo-delay 0)
           (company-minimum-prefix-length 1)
           (company-require-match nil)
           (company-dabbrev-ignore-case nil)
           (company-dabbrev-downcase nil)))
#+end_src
*** Company box
#+begin_src emacs-lisp
(use-package company-box
  :hook (company-mode . company-box-mode))
#+end_src

** Marginalia
#+begin_src emacs-lisp
(use-package marginalia
  :after vertico
  :custom (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
  :init (marginalia-mode))
#+end_src

** Which-key
#+begin_src emacs-lisp
(use-package which-key
  :config
  (setq which-key-idle-delay 0.25
        which-key-idle-secondary-delay 0.05
        which-key-show-remaining-keys nil)
  :init (which-key-mode)
  :bind ("C-c c w" . which-key-show-major-mode))
#+end_src

** Avy
#+begin_src emacs-lisp
(use-package avy
  :bind ("C-:" . avy-goto-char-timer))
#+end_src

** Embark
#+begin_src emacs-lisp
(use-package embark
  :ensure t
  :bind
  (("C-." . embark-act)         ;; pick some comfortable binding
   ("C-;" . embark-dwim)        ;; good alternative: M-.
   ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'
  :init
  ;; Optionally replace the key help with a completing-read interface
  (setq prefix-help-command #'embark-prefix-help-command)
  :config
  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))
#+end_src

*** Embark consult
#+begin_src emacs-lisp
(use-package embark-consult
  :ensure t
  :after (embark consult)
  :demand t ; only necessary if you have the hook below
  ;; if you want to have consult previews as you move around an
  ;; auto-updating embark collect buffer
  :hook (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

*** Embark use whick-key like a key menu prompt
#+begin_src emacs-lisp
(defun embark-which-key-indicator ()
  "An embark indicator that displays keymaps using which-key.
The which-key help message will show the type and value of the
current target followed by an ellipsis if there are further
targets."
  (lambda (&optional keymap targets prefix)
    (if (null keymap)
        (which-key--hide-popup-ignore-command)
      (which-key--show-keymap
       (if (eq (plist-get (car targets) :type) 'embark-become)
           "Become"
         (format "Act on %s '%s'%s"
                 (plist-get (car targets) :type)
                 (embark--truncate-target (plist-get (car targets) :target))
                 (if (cdr targets) "…" "")))
       (if prefix
           (pcase (lookup-key keymap prefix 'accept-default)
             ((and (pred keymapp) km) km)
             (_ (key-binding prefix 'accept-default)))
         keymap)
       nil nil t (lambda (binding)
                   (not (string-suffix-p "-argument" (cdr binding))))))))

(setq embark-indicators
      '(embark-which-key-indicator
        embark-highlight-indicator
        embark-isearch-highlight-indicator))

(defun embark-hide-which-key-indicator (fn &rest args)
  "Hide the which-key indicator immediately when using the completing-read prompter."
  (which-key--hide-popup-ignore-command)
  (let ((embark-indicators
         (remq #'embark-which-key-indicator embark-indicators)))
    (apply fn args)))

(advice-add #'embark-completing-read-prompter
            :around #'embark-hide-which-key-indicator)
#+end_src
** Projectile
   #+begin_src emacs-lisp
     (use-package projectile
       :ensure t
       :init (projectile-mode +1)
       :config (push "~/.cargo/registry/src" projectile-globally-ignored-directories)
       :bind ("C-c p" . projectile-command-map))
   #+end_src
** Yasnippet
#+begin_src emacs-lisp
(use-package yasnippet
  :config (yas-reload-all)
  (use-package yasnippet-snippets)
  :hook (prog-mode . yas-minor-mode))
#+end_src
** Language Server Protocol
*** LSP mode
#+begin_src emacs-lisp
(use-package lsp-mode
  :init (setq lsp-keymap-prefix "C-c l"
              lsp-eldoc-render-all nil
              ;; lsp-modeline-code-actions-mode t
              lsp-modeline-code-actions-segments '(count icon name)
              lsp-enable-on-type-formatting t
              lsp-enable-indentation t
              lsp-enable-folding t
              lsp-enable-snippet t
              lsp-semantic-tokens-enable nil
              lsp-lens-enable t
              lsp-log-io nil
              lsp-headerline-breadcrumb-icons-enable t
              lsp-idle-delay 0.2)
  :bind (:map lsp-mode-map
              ("C-c l r" . lsp-rename)
              ("C-c l a" . lsp-execute-code-action)
              ("C-c l t" . lsp-find-type-definition)
              ("C-c l e" . lsp-iedit-highlights))
  :config (define-key lsp-mode-map (kbd "C-c l") lsp-command-map)
  :commands lsp)
#+end_src
*** LSP UI
#+begin_src emacs-lisp
(use-package lsp-ui
  :init (setq lsp-ui-doc-enable nil
              ;; lsp-ui-doc-delay 0.2
              ;; lsp-ui-doc-show-with-cursor t
              ;; lsp-ui-doc-show-with-mouse t

              lsp-ui-sideline-show-diagnostics t
              lsp-ui-sideline-show-hover t
              lsp-ui-sideline-show-code-actions t

              lsp-ui-peek-enable t
              lsp-ui-peek-show-directory t

              lsp-completion-show-kind t
              lsp-completion-show-detail t)
  :bind (:map lsp-ui-mode-map
              ("M-." . lsp-ui-peek-find-definitions)
              ("M-?" . lsp-ui-peek-find-references)
              ("C-c l i" . lsp-ui-imenu)
              ("C-c l d" . lsp-ui-doc-show)))
;; (define-key lsp-ui-mode-map [remap xref-find-definitions] #'lsp-ui-peek-find-definitions)
;; (define-key lsp-ui-mode-map [remap xref-find-references] #'lsp-ui-peek-find-references)
#+end_src
** Linter
*** Flycheck
#+begin_src emacs-lisp
(use-package flycheck
  :config
  (add-to-list 'display-buffer-alist
               `(,(rx bos "*Flycheck errors*" eos)
                 (display-buffer-reuse-window
                  display-buffer-in-side-window)
                 (side            . bottom)
                 (reusable-frames . visible)
                 (window-height   . 0.33)))
  :init (global-flycheck-mode))
#+end_src

** Consult and integrations
*** Consult
#+begin_src emacs-lisp
(use-package consult
  ;; Replace bindings. Lazily loaded due by `use-package'.
  :bind (;; C-c bindings (mode-specific-map)
         ("C-c h" . consult-history)
         ("C-c m" . consult-mode-command)
         ;; C-x bindings (ctl-x-map)
         ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
         ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
         ;; Custom M-# bindings for fast register access
         ("M-#" . consult-register-load)
         ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
         ("C-M-#" . consult-register)
         ;; Other custom bindings
         ("M-y" . consult-yank-pop)                ;; orig. yank-pop
         ;; M-g bindings (goto-map)
         ("M-g f" . consult-flycheck)               ;; Alternative: consult-flycheck
         ("M-g g" . consult-goto-line)             ;; orig. goto-line
         ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
         ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
         ("M-g m" . consult-mark)
         ("M-g k" . consult-global-mark)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-imenu-multi)
         ;; M-s bindings (search-map)
         ("M-s f" . consult-find)
         ("M-s F" . consult-locate)
         ("M-s r" . consult-ripgrep)
         ("M-s l" . consult-line)
         ("M-s L" . consult-line-multi)
         ("M-s m" . consult-multi-occur)
         ("M-s k" . consult-keep-lines)
         ("M-s u" . consult-focus-lines)
         ;; Isearch integration
         ("M-s e" . consult-isearch-history)
         :map isearch-mode-map
         ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
         ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
         ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
         ("M-s L" . consult-line-multi))           ;; needed by consult-line to detect isearch

  ;; Enable automatic preview at point in the *Completions* buffer. This is
  ;; relevant when you use the default completion UI. You may want to also
  ;; enable `consult-preview-at-point-mode` in Embark Collect buffers.
  :hook (completion-list-mode . consult-preview-at-point-mode)

  ;; The :init configuration is always executed (Not lazy)
  :init

  ;; Optionally configure the register formatting. This improves the register
  ;; preview for `consult-register', `consult-register-load',
  ;; `consult-register-store' and the Emacs built-ins.
  (setq register-preview-delay 0
        register-preview-function #'consult-register-format)

  ;; Optionally tweak the register preview window.
  ;; This adds thin lines, sorting and hides the mode line of the window.
  (advice-add #'register-preview :override #'consult-register-window)

  ;; Optionally replace `completing-read-multiple' with an enhanced version.
  (advice-add #'completing-read-multiple :override #'consult-completing-read-multiple)

  ;; Use Consult to select xref locations with preview
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)

  ;; Use `consult-completion-in-region' if Vertico is enabled.
  ;; Otherwise use the default `completion--in-region' function.
  (setq completion-in-region-function
        (lambda (&rest args)
          (apply (if vertico-mode
                     #'consult-completion-in-region
                   #'completion--in-region)
                 args)))

  ;; Configure other variables and modes in the :config section,
  ;; after lazily loading the package.
  :config
  ;; Preview immediately theme on M-., on up/down after 0.5s, on any other key after 1s
  (consult-customize consult-theme
                     :preview-key
                     (list (kbd "M-.")
                           :debounce 0.5 (kbd "<up>") (kbd "<down>")
                           :debounce 1 'any))
  ;; Optionally configure the narrowing key.
  ;; Both < and C-+ work reasonably well.
  (setq consult-narrow-key "<") ;; (kbd "C-+")

  ;; Optionally make narrowing help available in the minibuffer.
  ;; You may want to use `embark-prefix-help-command' or which-key instead.
  ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

  ;; Configure S-up/S-down preview keys
  (define-key vertico-map [S-up] #'vertico-previous)
  (define-key vertico-map [S-down] #'vertico-next)
  (consult-customize consult-recent-file :preview-key '([S-up] [S-down]))
  ;; Optionally configure a function which returns the project root directory.
  ;; There are multiple reasonable alternatives to chose from.
    ;;;; 1. project.el (project-roots)
  (setq consult-project-root-function
        (lambda ()
          (when-let (project (project-current))
            (car (project-roots project))))))
#+end_src

*** Consult flycheck
#+begin_src emacs-lisp
  (use-package consult-flycheck
    :after (flycheck consult))
#+end_src

*** Consult company
#+begin_src emacs-lisp
  (use-package consult-company
    :after (company consult)
    :custom (define-key company-mode-map [remap completion-at-point] #'consult-company))
#+end_src

*** Consult projectile
#+begin_src emacs-lisp
  (use-package consult-projectile
    :after (consult projectile))
#+end_src

*** Consult yasnippet
#+begin_src emacs-lisp
  (use-package consult-yasnippet
    :after (yasnippet consult))
#+end_src

*** Consult LSP
#+begin_src emacs-lisp
  (use-package consult-lsp
    :after (consult marginalia lsp-mode))
#+end_src
* Programming
** Utils
*** Treesitter
#+begin_src emacs-lisp
  (use-package tree-sitter
    :init (use-package tree-sitter-langs)
    (global-tree-sitter-mode)
    :hook (tree-sitter-after-on-hook #'tree-sitter-hl-mode))
#+end_src
*** Parens
**** Smartparens
     #+begin_src emacs-lisp
       (use-package smartparens
         :bind ("C-M-f" . 'sp-forward-sexp)
         ("C-M-b" . 'sp-backward-sexp)
         :config (smartparens-global-mode)
         :init (smartparens-strict-mode t))
       ;; easy <'lifetime>
       (sp-with-modes 'rust-mode
         (sp-local-pair "<" ">")
         (sp-local-pair "'" nil :actions nil))
       ;; easy ~code~
       (sp-with-modes 'org-mode
         (sp-local-pair "~" "~")
         (sp-local-pair "=" "="))
     #+end_src
***** easy generics
      #+begin_src emacs-lisp
        (sp-with-modes 'rust-mode
          (sp-local-pair "<" ">")
          ;; easy lifetimes
          (sp-local-pair "'" nil :actions nil))
      #+end_src
***** close parens in new line
      #+begin_src emacs-lisp
        (sp-pair "{" nil :post-handlers '(("||\n[i]" "RET")))
        (sp-pair "(" nil :post-handlers '(("||\n[i]" "RET")))
        (sp-pair "[" nil :post-handlers '(("||\n[i]" "RET")))
      #+end_src

**** Show matches
#+begin_src emacs-lisp
(show-paren-mode 1)
(setq show-paren-style 'parenthesis)
(set-face-attribute 'show-paren-match nil :foreground "#FF3377" :weight 'regular :inherit t)
#+end_src
**** Rainbow delimiters
#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src
*** Git
**** Magit
#+begin_src emacs-lisp
  (use-package magit
    :config (setq magit-ediff-dwim-show-on-hunks t))
#+end_src

***** Magit TODOs
#+begin_src emacs-lisp
(use-package magit-todos
  :config (magit-todos-mode t))
#+end_src

**** Fringe Helper
#+BEGIN_SRC emacs-lisp
  (use-package fringe-helper
    :ensure t)
#+END_SRC

**** Git Gutter
#+BEGIN_SRC emacs-lisp
(use-package git-gutter
  :hook (prog-mode . git-gutter-mode)
  :config
  (use-package git-gutter-fringe
    :config
    (setq git-gutter-fr:side 'right-fringe)
    (setq-default right-fringe-width 15)
    (set-face-foreground 'git-gutter-fr:modified "#f5a97f")
    (set-face-background 'git-gutter-fr:modified "#f5a97f")
    (set-face-foreground 'git-gutter-fr:added    "#a6da95")
    (set-face-background 'git-gutter-fr:added    "#a6da95")
    (set-face-foreground 'git-gutter-fr:deleted  "#ed8796")
    (set-face-background 'git-gutter-fr:deleted  "#ed8796")))
#+END_SRC

**** blame
     #+begin_src emacs-lisp
       (use-package blamer
         :bind (("C-M-b" . blamer-show-posframe-commit-info))
         :defer 20
         :custom
         (blamer-idle-time 0.3)
         (blamer-min-offset 10)
         (blamer-type 'visual)
         (blamer-prettify-time-p t)
         (blamer-max-commit-message-length 72)
         (blamer-show-avatar-p t)
         (blamer-tooltip-function 'blamer-tooltip-commit-message)
         :custom-face
         (blamer-face ((t :italic nil)))
         :hook (prog-mode . blamer-mode))
     #+end_src
*** Region Expansion
#+begin_src emacs-lisp
  (use-package expand-region
    :bind ("C-c e =" . 'er/expand-region)
    ("C-c e p" . 'er/mark-inside-pairs)
    ("C-c e P" . 'er/mark-outside-pairs)
    ("C-c e q" . 'er/mark-inside-quotes)
    ("C-c e Q" . 'er/mark-outside-quotes)
    ("C-c e m" . 'er/mark-method-call)
    ("C-c e c" . 'er/mark-comment)
    ("C-c e -" . 'er/contract-region))
#+end_src
*** Moving lines around
#+begin_src emacs-lisp
  (use-package drag-stuff
    :hook (prog-mode . drag-stuff-mode)
    :config (drag-stuff-define-keys))
#+end_src
*** Auto reload files
#+begin_src emacs-lisp
  (global-auto-revert-mode t)
#+end_src
*** Save last cursor position
#+begin_src emacs-lisp
  (save-place-mode 1)
#+end_src
*** Auto highlight symbol
#+begin_src emacs-lisp
(use-package auto-highlight-symbol
  :ensure t
  :custom-face (ahs-definition-face ((t (:background "dark orange" :foreground "black"))))
  (ahs-face ((t (:background "orange" :foreground "black"))))
  (ahs-plugin-defalt-face ((t (:background "#1E2029" :foreground "dark orange"))))
  :hook (prog-mode . auto-highlight-symbol-mode))
#+end_src
*** Continue commenting on enter
    #+begin_src emacs-lisp
      (global-set-key (kbd "RET") 'default-indent-new-line)
    #+end_src
*** Get ansi-term
    #+begin_src emacs-lisp
      (defvar toggle-term-state nil)
      (defun toggle-term ()
        (interactive)
        (progn
          (if toggle-term-state
              (term-line-mode)
            (term-char-mode))
          (setq toggle-term-state (not toggle-term-state))))

      (use-package multi-term
        :custom (multi-term-program "/bin/zsh")
        :bind (("<f11>" . multi-term-dedicated-toggle)
               ("<f10>" . multi-term-dedicated-select)
               (:map term-mode-map
                     ("C-," . toggle-term))
               (:map term-raw-map
                     ("C-," . toggle-term))))
    #+end_src
*** Code folding
    #+begin_src emacs-lisp
      (use-package ts-fold
        :straight (ts-fold :type git :host github :repo "emacs-tree-sitter/ts-fold")
        :hook ((prog-mode . ts-fold-mode)
               (ts-fold-mode . ts-fold-line-comment-mode))
        :bind ("C-(" . ts-fold-toggle)
        :config (setq ts-fold-summary-format " summary: %s "))
    #+end_src
** Languages specifics
*** Rust
**** Rust mode
#+begin_src emacs-lisp
  (use-package rust-mode
    :init (setq rust-format-on-save nil)
    :hook (rust-mode . lsp))
#+end_src
**** LSP config
#+begin_src emacs-lisp
(setq lsp-rust-analyzer-lru-capacity (* 128 3) ;; default = 128
      lsp-rust-analyzer-server-display-inlay-hints t
      lsp-rust-analyzer-display-chaining-hints t
      lsp-rust-analyzer-display-parameter-hints t
      lsp-rust-analyzer-display-chaining-hints t
      lsp-rust-analyzer-display-closure-return-type-hints t
      lsp-rust-analyzer-display-lifetime-elision-hints-enable "always"
      lsp-rust-analyzer-display-lifetime-elision-hints-use-parameter-names t
      lsp-rust-analyzer-display-parameter-hints t
      lsp-rust-analyzer-display-reborrow-hints "always"
      lsp-rust-analyzer-max-inlay-hint-length 40
      lsp-rust-analyzer-hide-closure-initialization t
      lsp-rust-analyzer-hide-named-constructor t
      lsp-rust-analyzer-proc-macro-enable t)
#+end_src
**** When creating news language bugs
[[https://rustc-dev-guide.rust-lang.org/building/suggested.html#configuring-rust-analyzer-for-rustc][Configuring rust-analyzer for rustc]]
#+begin_src emacs-lisp
;; (setq
;;  lsp-rust-analyzer-rustfmt-override-command ["./build/x86_64-unknown-linux-gnu/stage0/bin/rustfmt", "--edition=2021"]
;;  lsp-rust-analyzer-cargo-run-build-scripts t
;;  lsp-rust-analyzer-rustc-source "./Cargo.toml"
;;  lsp-rust-analyzer-proc-macro-enable t)
#+end_src
*** Unison
**** Unison mode
#+begin_src emacs-lisp
(use-package unisonlang-mode)
#+end_src

*** Elixir
**** Elixir mode
#+begin_src emacs-lisp
  (use-package elixir-mode
    :hook (elixir-mode . lsp)
    :init (add-to-list 'exec-path "~/.elixir_ls/"))
#+end_src
**** Elixir snippets
#+begin_src emacs-lisp
  (use-package elixir-yasnippets)
#+end_src
**** Elixir flycheck
#+begin_src emacs-lisp
  (use-package flycheck-elixir)
#+end_src

*** Haskell
**** Haskell mode
#+begin_src emacs-lisp
(use-package haskell-mode)
#+end_src
**** LSP
#+begin_src emacs-lisp
(use-package lsp-haskell
  :hook (haskell-mode . lsp)
  (haskell-literate-mode . lsp))
#+end_src

*** Minors
**** TOML
#+begin_src emacs-lisp
  (use-package toml-mode)
#+end_src

**** YAML
#+begin_src emacs-lisp
  (use-package yaml-mode)
#+end_src
**** Dockerfile
#+begin_src emacs-lisp
  (use-package dockerfile-mode)
#+end_src

* Org
** install
#+begin_src emacs-lisp
(use-package org
  :defer t
  :ensure org-contrib)
#+end_src
** basic settings
#+begin_src emacs-lisp
  (setq
   ;; adapt indentation of content to match its heading
   org-adapt-indentation t
   org-ellipsis "  "
   org-hide-emphasis-markers t
   ;; non-nil = utf-8
   org-pretty-entities t
   org-startup-folded 'fold
   org-return-follows-link t
   ;; only needs one empty line to show an empty line when collapsed
   org-cycle-separator-lines 2
   ;; shift-select with mouse
   org-support-shift-select 'always
   ;; no help message when editing code
   org-edit-src-persistent-message nil
   org-insert-heading-respect-content t
   line-spacing 0.5)
#+end_src
** Custom faces
*** variable pitch
#+begin_src emacs-lisp
(use-package org-variable-pitch
  :hook org-mode-hook)
#+end_src

*** fixed pitch
#+begin_src emacs-lisp
(require 'org-indent)
(custom-theme-set-faces
 'user
 '(org-code ((t (:inherit (shadow fixed-pitch)))))
 '(org-indent ((t (:inherit (org-hide fixed-pitch))))))

(set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
(set-face-attribute 'org-table nil  :inherit 'fixed-pitch)
(set-face-attribute 'org-formula nil  :inherit 'fixed-pitch)
(set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-indent nil :inherit '(org-hide fixed-pitch))
(set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
(set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
(set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)
#+end_src

*** column views
#+begin_src emacs-lisp
(set-face-attribute 'org-column nil :background nil)
(set-face-attribute 'org-column-title nil :background nil)
#+end_src

*** window dividers
#+begin_src emacs-lisp
(dolist (face '(window-divider
                window-divider-first-pixel
                window-divider-last-pixel))
  (face-spec-reset-face face)
  (set-face-foreground face (face-attribute 'default :background)))
(set-face-background 'fringe (face-attribute 'default :background))
#+end_src
** bigger font in titles
Use latex style headings, https://github.com/integral-dw/org-superstar-mode/blob/master/DEMO.org#latex-style-headings
#+begin_src emacs-lisp
  (setq org-hidden-keywords '(title))
  ;; set basic title font
  (set-face-attribute 'org-level-8 nil :weight 'bold :inherit 'default)
  ;; Low levels are unimportant => no scaling
  (set-face-attribute 'org-level-7 nil :inherit 'org-level-8)
  (set-face-attribute 'org-level-6 nil :inherit 'org-level-8)
  (set-face-attribute 'org-level-5 nil :inherit 'org-level-8)
  (set-face-attribute 'org-level-4 nil :inherit 'org-level-8)
  ;; Top ones get scaled the same as in LaTeX (\large, \Large, \LARGE)
  (set-face-attribute 'org-level-3 nil :inherit 'org-level-8 :height 1.2) ;\large
  (set-face-attribute 'org-level-2 nil :inherit 'org-level-8 :height 1.44) ;\Large
  (set-face-attribute 'org-level-1 nil :inherit 'org-level-8 :height 1.728) ;\LARGE
  ;; Only use the first 4 styles and do not cycle.
  (setq org-cycle-level-faces nil)
  (setq org-n-level-faces 4)
  ;; Document Title, (\huge)
  (set-face-attribute 'org-document-title nil
                      :height 2.074
                      :foreground 'unspecified
                      :inherit 'org-level-8)
  ;; (set-face-attribute 'org-document-title nil :font "BlexMono Nerd Font" :weight 'bold :height 1.3)
  ;; (dolist (face '((org-level-1 . 1.2)
  ;;                 (org-level-2 . 1.1)
  ;;                 (org-level-3 . 1.05)
  ;;                 (org-level-4 . 1.0)
  ;;                 (org-level-5 . 1.1)
  ;;                 (org-level-6 . 1.1)
  ;;                 (org-level-7 . 1.1)
  ;;                 (org-level-8 . 1.1)))
  ;;   (set-face-attribute (car face) nil :font "BlexMono Nerd Font" :weight 'medium :height (cdr face)))
#+end_src

** Org superstar
#+begin_src emacs-lisp
  ;; org-superstar needs this way
  (setq org-hide-leading-stars nil)

  (use-package org-superstar
    :after org
    :init
    (setq org-superstar-headline-bullets-list '(?● ?○ ?◉)
          ;; fancy todo headings
          org-superstar-special-todo-items t
          ;; i use my own
          org-superstar-prettify-item-bullets nil)
    :hook (org-mode . org-superstar-mode))

  ;; This line is necessary.
  (setq org-superstar-leading-bullet ?\s)
  ;; If you use Org Indent you also need to add this, otherwise the
  ;; above has no effect while Indent is enabled.
  (setq org-indent-mode-turns-on-hiding-stars nil)
#+end_src

** make invisible parts visible
#+begin_src emacs-lisp
(use-package org-appear
  :hook org-mode-hook)
#+end_src
** Org mode as the *scratch* buffer
#+begin_src emacs-lisp
(setq initial-major-mode 'org-mode)
#+end_src
** Pretty checkboxes
https://jft.home.blog/2019/07/17/use-unicode-symbol-to-display-org-mode-checkboxes/
#+begin_src emacs-lisp
  (defface org-checkbox-done-text
      '((t (:foreground "#71696A" :strike-through t)))
      "Face for the text part of a checked org-mode checkbox.")

    (font-lock-add-keywords
     'org-mode
     `(("^[ \t]*\\(?:[-+*]\\|[0-9]+[).]\\)[ \t]+\\(\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\\)?\\[\\(?:X\\|\\([0-9]+\\)/\\2\\)\\][^\n]*\n\\)"
        1 'org-checkbox-done-text prepend))
     'append)

  (add-hook 'org-mode-hook (lambda ()
    "Beautify Org Checkbox Symbol"
    (push '("[ ]" . "☐") prettify-symbols-alist)
    (push '("[X]" . "☑" ) prettify-symbols-alist)
    (push '("[-]" . "❍" ) prettify-symbols-alist)
    (prettify-symbols-mode)))
#+end_src
** Pretty bullet list
#+begin_src emacs-lisp
(font-lock-add-keywords 'org-mode
                        '(("^ *\\([-]\\) "
                           (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+end_src
** Centralized
#+begin_src emacs-lisp
  (use-package olivetti
    :hook
    (org-mode . olivetti-mode)
    (markdown-mode . olivetti-mode)
    :config (setq-default olivetti-body-width 140))

  (setq-default default-justification 'full)
#+end_src
** Org-roam
*** Load org-fold
#+begin_src emacs-lisp
(require 'org-fold)
#+end_src
*** Install it
    #+begin_src emacs-lisp
      (use-package org-roam
        :custom
        (org-roam-directory (file-truename "~/projects/brainiac/"))
        (org-roam-db-location (file-truename "~/projects/brainiac/org-roam.db"))
        (org-roam-dailies-directory "dailies/")
        (org-roam-completion-everywhere t)
        (org-roam-dailies-capture-templates
         '(("d" "default" entry
            "\n\n* %<%I:%M %p>: %?"
            :if-new (file+head "%<%Y-%m-%d>.org"
                               "#+OPTIONS: ^:nil\n#+title: %<%Y-%m-%d>\n"))))
        (org-roam-capture-templates
         '(("d" "default" plain
            "%?"
            :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                               "#+OPTIONS: ^:nil\n#+title: ${title}\n#+date: %U")
            :unnarrowed t) 
           ("p" "paper notes" plain
            "\n\n* Reference\nAuthors: %^{Author}\nTitle: ${title}\nYear: %^{year}\nLink: %^{link}\n\n* Summary\n%?"
            :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                               "#+OPTIONS: ^:nil\n#+title: ${title}\n#+filetags: paper")
            :unnarrowed t)
           ("s" "project notes" plain
            "\n\n* Description\n%?\n* Tasks"
            :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                               "#+OPTIONS: ^:nil\n#+title: ${title}\n#+filetags: project"))
           ("t" "task" plain
            "\n\n* Description\n\n** Context\n%?\n** What we need to do\n\n* Subtasks"
            :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                               "#+OPTIONS: ^:nil\n#+title: ${title}\n#+filetags: task"))))
        :bind (("C-c b f" . org-roam-node-find)
               ("C-c b i" . org-roam-node-insert)
               ("C-c b c" . org-roam-capture)
               ("C-c b d" . org-roam-dailies-capture-today)
               ("C-c b D" . org-roam-dailies-goto-today)
               ("C-c b y" . org-roam-dailies-goto-previous))
        :config
        (setq org-roam-node-display-template
              (concat "${title:*} "
                      (propertize "${tags:10}" 'face 'org-tag)))
        (org-roam-db-autosync-mode))
    #+end_src
*** Org-roam-ui
    #+begin_src emacs-lisp
      (use-package org-roam-ui
        :config
        (setq org-roam-ui-sync-theme t
              org-roam-ui-follow t
              org-roam-ui-update-on-save t
              org-roam-ui-open-on-start t)
        (defun open-org-roam-ui ()
          (interactive)
          (when (not(bound-and-true-p org-roam-ui-mode))
            (org-roam-ui-mode))
          (org-roam-ui-open))
        :bind
        ("C-c b g" . open-org-roam-ui))
    #+end_src
*** Deft
#+begin_src emacs-lisp
(use-package deft
  :after org
  :bind
  ("<f8>" . deft)
  :custom
  (deft-recursive t)
  (deft-use-filter-string-for-filename t)
  (deft-default-extension "org")
  (deft-directory (file-truename "~/projects/brainiac")))

(defun cm/deft-parse-title (file contents)
  "Parse the given FILE and CONTENTS and determine the title.
   If `deft-use-filename-as-title' is nil, the title is taken to
   be the first non-empty line of the FILE.  Else the base name of the FILE is
   used as title."
  (let ((begin (string-match "^#\\+[tT][iI][tT][lL][eE]: .*$" contents)))
    (if begin
        (string-trim (substring contents begin (match-end 0)) "#\\+[tT][iI][tT][lL][eE]: *" "[\n\t ]+")
      (deft-base-filename file))))

(advice-add 'deft-parse-title :override #'cm/deft-parse-title)

(setq deft-strip-summary-regexp
      (concat "\\("
              "[\n\t]" ;; blank
              "\\|^#\\+[[:alpha:]_]+:.*$" ;; org-mode metadata
              "\\|^:PROPERTIES:\n\\(.+\n\\)+:END:\n"
              "\\)"))
#+end_src
** Code blocks
*** Framing
   #+begin_src emacs-lisp
     (use-package org-modern-indent
       :hook (org-mode . org-modern-indent-mode)
       :straight (org-modern-indent :type git :host github :repo "jdtsmith/org-modern-indent"))
   #+end_src
*** hide src blocks
    from https://emacs.stackexchange.com/a/31623
    #+begin_src emacs-lisp
      (with-eval-after-load 'org
        (defvar-local rasmus/org-at-src-begin -1
          "Variable that holds whether last position was a ")
        (defvar rasmus/ob-header-symbol ?☰
          "Symbol used for babel headers")
        (defun rasmus/org-prettify-src--update ()
          (let ((case-fold-search t)
                (re "^[ \t]*#\\+begin_src[ \t]+[^ \f\t\n\r\v]+[ \t]*")
                found)
            (save-excursion
              (goto-char (point-min))
              (while (re-search-forward re nil t)
                (goto-char (match-end 0))
                (let ((args (org-trim
                             (buffer-substring-no-properties (point)
                                                             (line-end-position)))))
                  (when (org-string-nw-p args)
                    (let ((new-cell (cons args rasmus/ob-header-symbol)))
                      (cl-pushnew new-cell prettify-symbols-alist :test #'equal)
                      (cl-pushnew new-cell found :test #'equal)))))
              (setq prettify-symbols-alist
                    (cl-set-difference prettify-symbols-alist
                                       (cl-set-difference
                                        (cl-remove-if-not
                                         (lambda (elm)
                                           (eq (cdr elm) rasmus/ob-header-symbol))
                                         prettify-symbols-alist)
                                        found :test #'equal)))
              ;; Clean up old font-lock-keywords.
              (font-lock-remove-keywords nil prettify-symbols--keywords)
              (setq prettify-symbols--keywords (prettify-symbols--make-keywords))
              (font-lock-add-keywords nil prettify-symbols--keywords)
              (while (re-search-forward re nil t)
                (font-lock-flush (line-beginning-position) (line-end-position))))))

        (defun rasmus/org-prettify-src ()
          "Hide src options via `prettify-symbols-mode'.

        `prettify-symbols-mode' is used because it has uncollpasing. It's
        may not be efficient."
          (let* ((case-fold-search t)
                 (at-src-block (save-excursion
                                 (beginning-of-line)
                                 (looking-at "^[ \t]*#\\+begin_src[ \t]+[^ \f\t\n\r\v]+[ \t]*"))))
            ;; Test if we moved out of a block.
            (when (or (and rasmus/org-at-src-begin
                           (not at-src-block))
                      ;; File was just opened.
                      (eq rasmus/org-at-src-begin -1))
              (rasmus/org-prettify-src--update))
            (setq rasmus/org-at-src-begin at-src-block)))

        (defun rasmus/org-prettify-symbols ()
          (mapc (apply-partially 'add-to-list 'prettify-symbols-alist)
                (cl-reduce 'append
                           (mapcar (lambda (x) (list x (cons (upcase (car x)) (cdr x))))
                                   `(("#+begin_src" . ?□)
                                     ("#+end_src"   . ?□)
                                     ("#+header:" . ,rasmus/ob-header-symbol)
                                     ("#+begin_quote" . ?»)
                                     ("#+end_quote" . ?«)
                                     ("#+begin_comment" . ?💭)
                                     ("#+end_comment" . ?□)))))
          (turn-on-prettify-symbols-mode)
          (add-hook 'post-command-hook 'rasmus/org-prettify-src t t))
        (add-hook 'org-mode-hook #'rasmus/org-prettify-symbols))
    #+end_src
** Automatically set task to DONE when all children are complete
   [[https://orgmode.org/manual/Breaking-Down-Tasks.html][doc]]
   #+begin_src emacs-lisp
     (defun org-summary-todo (n-done n-not-done)
       "Switch entry to DONE when all subentries are done, to TODO otherwise."
       (let (org-log-done org-log-states)   ; turn off logging
         (org-todo (if (= n-not-done 0) "DONE" "TODO"))))
     (add-hook 'org-after-todo-statistics-hook #'org-summary-todo)
   #+end_src
*** automatically set task DONE when all checkboxes are complete
    [[https://emacs.stackexchange.com/a/22147][source]]
    #+begin_src emacs-lisp
      (defun my/org-checkbox-todo ()
        "Switch header TODO state to DONE when all checkboxes are ticked, to TODO otherwise"
        (let ((todo-state (org-get-todo-state)) beg end)
          (unless (not todo-state)
            (save-excursion
          (org-back-to-heading t)
          (setq beg (point))
          (end-of-line)
          (setq end (point))
          (goto-char beg)
          (if (re-search-forward "\\[\\([0-9]*%\\)\\]\\|\\[\\([0-9]*\\)/\\([0-9]*\\)\\]"
                         end t)
              (if (match-end 1)
              (if (equal (match-string 1) "100%")
                  (unless (string-equal todo-state "DONE")
                    (org-todo 'done))
                (unless (string-equal todo-state "TODO")
                  (org-todo 'todo)))
                (if (and (> (match-end 2) (match-beginning 2))
                     (equal (match-string 2) (match-string 3)))
                (unless (string-equal todo-state "DONE")
                  (org-todo 'done))
              (unless (string-equal todo-state "TODO")
                (org-todo 'todo)))))))))

      (add-hook 'org-checkbox-statistics-hook 'my/org-checkbox-todo)
    #+end_src
* Utils
** Easy increase/decrease font size
#+begin_src emacs-lisp
(global-set-key (kbd "C-+") #'text-scale-increase)
(global-set-key (kbd "C--") #'text-scale-decrease)
#+end_src
** Kill current buffer
#+begin_src emacs-lisp
(global-set-key (kbd "C-x k") 'kill-this-buffer)
#+end_src

** Use y-or-n
#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

** Use spaces
#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)

(defun consoli/infer-indentation-style ()
  "If our source file use tabs, we use tabs, if spaces, spaces.
    And if neither, we use the current indent-tabs-mode"
  (let ((space-count (how-many "^ " (point-min) (point-max)))
        (tab-count (how-many "^\t" (point-min) (point-max))))
    (if (> space-count tab-count) (setq indent-tabs-mode nil))
    (if (> tab-count space-count) (setq indent-tabs-mode t))))
;; (add-hook 'prog-mode-hook #'consoli/infer-indentation-style)
#+end_src
** Don't freeze
   #+begin_src emacs-lisp
     (defun suspend-if-in-shell ()
       "suspend process if the instance is not running in GUI"
       (progn
         (when (not (display-graphic-p))
           (suspend-emacs))))
     (global-set-key (kbd "C-z") (lambda () (interactive) (suspend-if-in-shell)))
   #+end_src
** Delete selection
#+begin_src emacs-lisp
(pending-delete-mode t)
(delete-selection-mode t)
#+end_src
** Smooth scrolling
#+begin_src emacs-lisp
(use-package good-scroll
  :custom (redisplay-dont-pause 1)
  :config (good-scroll-mode 1))
#+end_src
*** Preserve screen position
#+begin_src emacs-lisp
(setq scroll-preserve-screen-position t
      scroll-conservatively 101)
#+end_src
** Backup files
*** Change backup directory
    By default, emacs saves the ~backup~~ files in the same directory the file is.
   #+begin_src emacs-lisp
     (setq backup-directory-alist `(("." . "~/.emacs.d/backup/per-save")))
   #+end_src
*** More backup files
    #+begin_src emacs-lisp
      (setq delete-old-versions t
            ;; number of new versions of a file to kept
            kept-new-versions 4
            ;; number of old version to kept
            kept-old-versions 3
            ;; numeric version control
            version-control t
            ;; copy files, dont rename them
            backup-by-copying t)
    #+end_src
*** Auto-save files
    Auto-save files are temporary files that Emacs creates until a file is saved.
    Emacs auto-saves whenever it crashes, after ~N~ keystrokes and after a timeout.
    #+begin_src emacs-lisp
      (setq auto-save-timeout 10 ;; seconds
            ;; keystrokes
            auto-save-interval 200)
    #+end_src
*** force backup of buffer
    https://stackoverflow.com/a/20824625
    #+begin_src emacs-lisp
      (defun force-backup-of-buffer ()
        ;; Make a special "per session" backup at the first save of each
        ;; emacs session.
        (when (not buffer-backed-up)
          ;; Override the default parameters for per-session backups.
          (let ((backup-directory-alist '(("" . "~/.emacs.d/backup/per-session")))
                (kept-new-versions 3))
            (backup-buffer)))
        ;; Make a "per save" backup on each save.  The first save results in
        ;; both a per-session and a per-save backup, to keep the numbering
        ;; of per-save backups consistent.
        (let ((buffer-backed-up nil))
          (backup-buffer)))
      (add-hook 'before-save-hook  'force-backup-of-buffer)
    #+end_src
** Do what I mean
   #+begin_src emacs-lisp
     (global-set-key (kbd "M-u") 'upcase-dwim)
     (global-set-key (kbd "M-l") 'downcase-dwim)
     (global-set-key (kbd "M-c") 'capitalize-dwim)
   #+end_src
** A [C]ollection of [R]idiculous [U]seful e[X]tensions
   #+begin_src emacs-lisp
     (use-package crux
       :bind ([remap kill-line] . crux-smart-kill-line)
       ([remap kill-whole-line] . crux-kill-whole-line)
       ("C-c n" . crux-cleanup-buffer-or-region)
       ("C-c d" . crux-duplicate-current-line-or-region)
       ("C-c M-d" . crux-duplicate-and-comment-current-line-or-region))
   #+end_src
** Read $PATH
#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :init (exec-path-from-shell-initialize))
#+end_src
** Smart go to beginning of line
#+begin_src emacs-lisp
(defun smarter-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.
Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and the beginning of the line.
If ARG is not nil or 1, move forward ARG - 1 lines first. If point reaches the beginning or end of the buffer, stop there."

  (interactive "^p")
  (setq arg (or arg 1))
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))
  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

(global-set-key [remap move-beginning-of-line] 'smarter-beginning-of-line)
#+end_src
** Open lines around
   #+begin_src emacs-lisp
     (defun consoli/insert-new-line-bellow ()
       (interactive)
       (let ((current-point (point)))
         (move-end-of-line 1)
         (open-line 1)
         (goto-char current-point)))
     (global-set-key (kbd "C-S-<down>") 'consoli/insert-new-line-bellow)

     (defun consoli/insert-new-line-above ()
       (interactive)
       (let ((current-point (point)))
         (move-beginning-of-line 1)
         (newline-and-indent)
         (indent-according-to-mode)
         (goto-char current-point)
         (forward-char)))
     (global-set-key (kbd "C-S-<up>") 'consoli/insert-new-line-above)
   #+end_src
** Hide unwanted buffers when cycling
#+begin_src emacs-lisp
(set-frame-parameter (selected-frame) 'buffer-predicate #'buffer-file-name)
#+end_src

** Hide native compile logs
#+begin_src emacs-lisp
(setq native-comp-async-report-warnings-errors nil)
#+end_src

** no bell
#+begin_src emacs-lisp
(setq ring-bell-function 'ignore)
#+end_src    
** Spell checking
*** Jinx
    #+begin_src emacs-lisp 
      (use-package jinx
        :hook (emacs-startup . global-jinx-mode)
        ;; `M-$` correct the word at point
        :custom (jinx-languages "en_UK en_US pt_BR")
        :bind ([remap ispell-word] . jinx-correct))
    #+end_src
* Appearance
** Modeline
   #+begin_src emacs-lisp
     (use-package doom-modeline
       :custom
       (doom-modeline-height 50)
       (doom-modeline-hud nil)
       (doom-modeline-enable-word-count t)
       (doom-modeline-buffer-encoding nil)
       :hook (after-init . doom-modeline-mode))
   #+end_src
*** Clock
    #+BEGIN_SRC emacs-lisp
      (setq-default display-time-default-load-average nil)
      (setq display-time-format "%I:%M %p")
      (display-time-mode 1)
    #+END_SRC
*** Only render the modeline in the active window
    #+begin_src emacs-lisp
      (set-face-attribute 'mode-line-inactive nil
                          :underline nil
                          :background (face-background 'default))
    #+end_src

** All the icons
#+begin_src emacs-lisp
  (use-package all-the-icons)
#+end_src
** Themes
*** Doom themes
    #+begin_src emacs-lisp
      (use-package doom-themes
        :config (doom-themes-org-config)
        :custom
        (doom-themes-enable-bold t)
        (doom-themes-enable-italic t))
    #+end_src
**** Solaire-mode
     #+begin_src emacs-lisp
       (use-package solaire-mode
         :config (solaire-global-mode t))
       (add-to-list 'solaire-mode-themes-to-face-swap "^doom-")
     #+end_src
*** catppuccin
    #+begin_src emacs-lisp
      (use-package catppuccin-theme
        :init
        (setq catppuccin-flavor 'macchiato))
    #+end_src
*** Load theme
    #+begin_src emacs-lisp
      (load-theme 'catppuccin
                  :no-confirm)
    #+end_src
** UI
*** Splash screen
#+begin_src emacs-lisp
  (setq inhibit-startup-screen t)
#+end_src
*** Scratch buffer message
#+begin_src emacs-lisp
  (setq initial-scratch-message nil
    inhibit-startup-echo-area-message t)
#+end_src
*** Scroll bar
#+begin_src emacs-lisp
  (scroll-bar-mode -1)
#+end_src
*** Menu bar
#+begin_src emacs-lisp
  (menu-bar-mode -1)
#+end_src
*** Tool bar
#+begin_src emacs-lisp
  (tool-bar-mode -1)
#+end_src
*** Cursor type
#+begin_src emacs-lisp
  (setq-default cursor-type 'bar)
#+end_src
*** Highlight line
#+begin_src emacs-lisp
  (global-hl-line-mode t)
#+end_src
*** Only highlight text region
#+begin_src emacs-lisp
(set-face-attribute 'region nil :extend nil)
#+end_src
*** Line numbers
**** Hook
#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
#+end_src
**** Format
#+begin_src emacs-lisp
  (fringe-mode '(15 . 10))
#+end_src
** Font
*** Set font
    #+begin_src emacs-lisp
      (add-to-list 'default-frame-alist '(font . "BlexMono Nerd Font-14"))
      (set-face-attribute 'default t :font "BlexMono Nerd Font")
      (global-auto-composition-mode t)
    #+end_src
*** Italic comments
#+begin_src emacs-lisp
(custom-set-faces
 '(font-lock-comment-face ((t (:slant italic)))))
#+end_src
*** Pretty symbols
#+begin_src emacs-lisp
(when window-system
  (add-hook 'prog-mode-hook 'prettify-symbols-mode))
#+end_src
*** Fix org mode tables
#+begin_src emacs-lisp
(set-face-attribute 'org-table nil :inherit 'fixed-pitch)
#+end_src
