* lexical binding
#+begin_src emacs-lisp
  ;;; -*- lexical-binding: t -*-
#+end_src

* compile angel
#+begin_src emacs-lisp
  (use-package compile-angel
    :ensure t
    :demand t
    :config
    ;; Set `compile-angel-verbose' to nil to disable compile-angel messages.
    ;; (When set to nil, compile-angel won't show which file is being compiled.)
    (setq compile-angel-verbose nil)

    ;; Uncomment the line below to compile automatically when an Elisp file is saved
    (add-hook 'emacs-lisp-mode-hook #'compile-angel-on-save-local-mode)

    ;; A global mode that compiles .el files before they are loaded
    ;; using `load' or `require'.
    (compile-angel-on-load-mode))
#+end_src
* Completion system
** preview mode
#+begin_src emacs-lisp
  (add-hook 'after-init-hook #'global-completion-preview-mode)
#+end_src
** Vertico
   #+begin_src emacs-lisp
     (use-package vertico
       :custom
       (vertico-cycle t)
       :hook
       (after-init . vertico-mode)
       (after-init . vertico-multiform-mode))

     (use-package savehist
       :hook (after-init . savehist-mode))

     (use-package emacs
       :custom
       ;; Support opening new minibuffers from inside existing minibuffers.
       (enable-recursive-minibuffers t)
       ;; Hide commands in M-x which do not work in the current mode.  Vertico
       ;; commands are hidden in normal buffers. This setting is useful beyond
       ;; Vertico.
       (read-extended-command-predicate #'command-completion-default-include-p)
       :init
       ;; Add prompt indicator to `completing-read-multiple'.
       ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
       (defun crm-indicator (args)
         (cons (format "[CRM%s] %s"
                       (replace-regexp-in-string
                        "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                        crm-separator)
                       (car args))
               (cdr args)))
       (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

       ;; Do not allow the cursor in the minibuffer prompt
       (setq minibuffer-prompt-properties
             '(read-only t cursor-intangible t face minibuffer-prompt))
       (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode))
   #+end_src
*** COMMENT posframe
#+begin_src emacs-lisp
  (use-package vertico-posframe
    :config
    (defvar my-vertico-disable-posframe-commands
      '(consult-line consult-todo consult-ripgrep))

    (setq vertico-multiform-commands
          (append
           (mapcar (lambda (cmd) `(,cmd (:not posframe)))
                   my-vertico-disable-posframe-commands)
           '((t posframe))))
    (setq vertico-posframe-poshandler #'posframe-poshandler-frame-top-center)
    (vertico-posframe-mode 1))
#+end_src
** LSP - Language Server Protocol
*** eglot
#+begin_src emacs-lisp
  (use-package eglot
    :defer t
    :init
    (defvar eglot-mode-map (make-sparse-keymap)
      "Keymap for eglot commands.")
    :custom
    ;; Basic settings
    (eglot-autoshutdown t)
    (eglot-sync-connect-timeout 30)
    (eglot-events-buffer-size 0)
    (eglot-connect-timeout 30)
    ;; Eldoc settings (equivalent to lsp eldoc settings)
    (eldoc-echo-area-use-multiline-p nil)
    (eldoc-echo-area-display-truncation-message nil)
    ;; Events to trigger LSP
    (eglot-send-changes-idle-time 0.3) ;; equivalent to lsp-idle-delay
    
    :config
    ;; Completion settings with Corfu
    (advice-add 'eglot-completion-at-point :around #'cape-wrap-noninterruptible)
    
    (defun my/orderless-dispatch-flex-first (_pattern index _total)
      "Set `orderless-flex` for the first component of a pattern."
      (and (eq index 0) 'orderless-flex))
    
    (defun my/eglot-mode-setup-completion ()
      "Configure completion for Eglot-managed buffers."
      ;; This tells completion to use `orderless` for the `eglot` CAPF.
      (setf (alist-get 'styles (alist-get 'lsp completion-category-defaults))
            '(orderless))
      ;; Configure the first word as flex-filtered.
      (add-hook 'orderless-style-dispatchers #'my/orderless-dispatch-flex-first nil 'local)
      ;; Use Cape's buster to make Eglot's completion more robust.
      (setq-local completion-at-point-functions
                  (list (cape-capf-buster #'eglot-completion-at-point))))
    
    ;; Auto-save after rename
    (advice-add 'eglot--apply-workspace-edit :after
                (lambda (&rest _)
                  (dolist (buffer (buffer-list))
                    (with-current-buffer buffer
                      (when (and buffer-file-name (buffer-modified-p))
                        (save-buffer))))))

    (add-to-list 'eglot-server-programs
                 '(toml-ts-mode . '("taplo" "lsp" "stdio")))
    
    :bind (:map eglot-mode-map
                ("C-c l r" . eglot-rename)
                ("C-c l a" . eglot-code-actions)
                ("C-c l t" . eglot-find-type-definition)
                ("C-c l v" . consult-eglot-symbols)
                ("<f4>" . eglot-inlay-hints-mode))
    
    :hook ((prog-mode . eglot-ensure)
           (eglot-managed-mode . my/eglot-mode-setup-completion)
           (eglot-managed-mode . eglot-inlay-hints-mode))) ;; enable by default
#+end_src
**** eglot booster
#+begin_src emacs-lisp
  (use-package eglot-booster
    :straight (:host github :repo "jdtsmith/eglot-booster")
    :hook (eglot-managed . eglot-booster-mode))
#+end_src
**** consult eglot
#+begin_src emacs-lisp
  (use-package consult-eglot
    :after (consult eglot)
    :bind (:map eglot-mode-map
                ("C-c l s" . consult-eglot-symbols)
                ("C-c l i" . consult-imenu)
                ("C-c l e" . consult-flycheck)))
#+end_src
**** eldoc-box
#+begin_src emacs-lisp
  (use-package eldoc-box
    :custom
    (eldoc-box-max-pixel-width 600)
    (eldoc-box-max-pixel-height 400)
    (eldoc-box-clear-with-C-g t)
    (eldoc-box-cleanup-internval 0.3)
    (eldoc-idle-delay 1.5)
    (eldoc-box-position-function #'eldoc-box--default-at-point-position-function)
    :config
    (defun my-eldoc-box-bottom-right-position (width height)
      "Position eldoc-box at bottom-right, accounting for box dimensions."
      (let* ((window (selected-window))
             (frame (window-frame window))
             (window-edges (window-pixel-edges window))
             (window-right (nth 2 window-edges))
             (window-bottom (nth 3 window-edges))
             (margin-x 10)  ; Pixels from right edge
             (margin-y 40)) ; Pixels from bottom
        (cons (- window-right width margin-x)
              (- window-bottom height margin-y))))

    (setq eldoc-box-position-function #'my-eldoc-box-bottom-right-position)
    :bind (:map eglot-mode-map
                ("C-c l d" . eldoc-box-help-at-point))
    :hook (eglot-managed-mode . eldoc-box-hover-mode))
#+end_src
**** breadcrumb
#+begin_src emacs-lisp
  (use-package breadcrumb
    :after eglot
    :hook (eglot-managed-mode . breadcrumb-mode)
    :custom
    (breadcrumb-project-max-length 0.5)
    (breadcrumb-project-crumb-separator "/")
    (breadcrumb-imenu-max-length 0.5))
#+end_src
***** icons hack
https://github.com/joaotavora/breadcrumb/issues/6#issuecomment-2181911984
#+begin_src emacs-lisp
  (advice-add #'breadcrumb--format-project-node :around
              (lambda (og p more &rest r)
                "Icon For File"
                (let ((string (apply og p more r)))
                  (if (not more)
                      (concat (nerd-icons-icon-for-file string)
                              " " string)
                    (concat (nerd-icons-faicon
                             "nf-fa-folder_open"
                             :face 'breadcrumb-project-crumbs-face)
                            " "
                            string)))))

  (advice-add #'breadcrumb--project-crumbs-1 :filter-return
              (lambda (return)
                "Icon for Parent Node"
                (if (listp return)
                    (setf (car return)
                          (concat
                           " "
                           (nerd-icons-faicon
                            "nf-fa-rocket"
                            :face 'breadcrumb-project-base-face)
                           " "
                           (car return))))
                return))

  (advice-add #'breadcrumb--format-ipath-node :around
              (lambda (og p more &rest r)
                "Icon for items"
                (let ((string (apply og p more r)))
                  (if (not more)
                      (concat (nerd-icons-codicon
                               "nf-cod-symbol_field"
                               :face 'breadcrumb-imenu-leaf-face)
                              " " string)
                    (cond ((string= string "Packages")
                           (concat (nerd-icons-codicon "nf-cod-package" :face 'breadcrumb-imenu-crumbs-face) " " string))
                          ((string= string "Requires")
                           (concat (nerd-icons-codicon "nf-cod-file_submodule" :face 'breadcrumb-imenu-crumbs-face) " " string))
                          ((or (string= string "Variable") (string= string "Variables"))
                           (concat (nerd-icons-codicon "nf-cod-symbol_variable" :face 'breadcrumb-imenu-crumbs-face) " " string))
                          ((string= string "Function")
                           (concat (nerd-icons-mdicon "nf-md-function_variant" :face 'breadcrumb-imenu-crumbs-face) " " string))
                          (t string))))))
#+end_src
**** flycheck
#+begin_src emacs-lisp
  (use-package flycheck-eglot
    :after (flycheck eglot)
    :config
    (global-flycheck-eglot-mode 1))
#+end_src
**** eglot-x
#+begin_src emacs-lisp
  (use-package eglot-x
    :straight (:host github :repo "nemethf/eglot-x")
    :after eglot
    :custom
    (eglot-x-enable-colored-diagnostics t)
    (eglot-x-enable-server-status t)
    (eglot-x-enable-snippet-text-edit t)
    :bind
    (:map eglot-mode-map
          ("M-S-." . eglot-x-find-refs)
          ("C-c l R" . eglot-x-ask-runnables)
          ("C-c l w" . eglot-x-find-workspace-symbol)
          ("C-c l o" . eglot-x-open-external-documentation)
          ("C-c l s" . eglot-x-structural-search-replace))
    :hook (eglot . eglot-x-setup))
#+end_src
**** sideline
#+begin_src emacs-lisp
  (use-package sideline-eglot
    :defer t)

  (use-package sideline-flycheck
    :defer t
    :hook (flycheck-mode . sideline-flycheck-setup))

  (use-package sideline
    :defer t
    :hook (eglot-managed-mode . sideline-mode)
    :custom
    (sideline-backends-right '(sideline-eglot sideline-flycheck))
    (sideline-display-backend-name t)
    (sideline-delay 0.4)
    (sideline-truncate t))
#+end_src
**** apheleia - format on save
#+begin_src emacs-lisp
  (use-package apheleia
    :hook (prog-mode . apheleia-mode)
    :config
    (require 'cl-lib)
    (cl-defun apheleia-indent-eglot-managed-buffer
        (&key buffer scratch callback &allow-other-keys)
      "Copy BUFFER to SCRATCH, then format scratch, then call CALLBACK."
      (with-current-buffer scratch
        (setq-local eglot--cached-server
                    (with-current-buffer buffer
                      (eglot-current-server)))
        (let ((buffer-file-name (buffer-local-value 'buffer-file-name buffer)))
          (eglot-format-buffer))
        (funcall callback)))
    (add-to-list 'apheleia-formatters
                 '(eglot-managed . apheleia-indent-eglot-managed-buffer)))
#+end_src
** dabbrev
   #+begin_src emacs-lisp
     (setq-default abbrev-mode t)
     (use-package dabbrev
       :defer t
       :bind (("M-/" . dabbrev-completion)
              ("C-M-/" . dabbrev-expand))
       :config
       (add-to-list 'dabbrev-ignored-buffer-regexps "\\` ")
       ;; Since 29.1, use `dabbrev-ignored-buffer-regexps' on older.
       (add-to-list 'dabbrev-ignored-buffer-modes 'doc-view-mode)
       (add-to-list 'dabbrev-ignored-buffer-modes 'pdf-view-mode)
       (add-to-list 'dabbrev-ignored-buffer-modes 'tags-table-mode))
   #+end_src
** cape
   #+begin_src emacs-lisp
     (use-package cape
       :bind ("M-p" . cape-prefix-map)
       :init
       (setq-local completion-at-point-functions
                   (list (cape-capf-super #'cape-dabbrev #'cape-dict #'cape-keyword #'cape-file #'cape-history))))
   #+end_src
** Orderless
   #+begin_src emacs-lisp
     (use-package orderless
       :init
       (setq completion-styles '(orderless substring partial-completion basic)
             completion-category-defaults nil
             completion-category-overrides '((file (styles basic partial-completion)))))
   #+end_src
** Corfu
   #+begin_src emacs-lisp
     (use-package corfu
       :hook
       (after-init . global-corfu-mode)
       (after-init . corfu-history-mode)
       (after-init . corfu-popupinfo-mode)

       :custom
       (corfu-cycle t)
       (corfu-scroll-margin 2)
       (corfu-preselect 'first)
       (corfu-preview-current nil)
       (corfu-quit-no-match 'separator)
       (corfu-quit-at-boundary t)
       (corfu-separator ?\s)

       (corfu-auto t)
       (corfu-auto-delay 0.2)
       (corfu-auto-prefix 2)
       (corfu-popupinfo-delay '(1.30 . 1.50))
       :bind
       (:map corfu-map
             ("M-q" . corfu-quick-complete)
             ("C-i" . corfu-quick-insert)))
   #+end_src
*** icons for corfu
    #+begin_src emacs-lisp
      (use-package nerd-icons-corfu
        :after corfu
        :config
        (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))
    #+end_src
*** corfu in the minibuffer
    #+begin_src emacs-lisp
      (defun corfu-enable-in-minibuffer ()
        "Enable Corfu in the minibuffer."
        (when (local-variable-p 'completion-at-point-functions)
          ;; (setq-local corfu-auto nil) ;; Enable/disable auto completion
          (setq-local corfu-echo-delay nil ;; Disable automatic echo and popup
                      corfu-popupinfo-delay nil)
          (corfu-mode 1)))
      (add-hook 'minibuffer-setup-hook #'corfu-enable-in-minibuffer)
    #+end_src
** Marginalia
   #+begin_src emacs-lisp
     (use-package marginalia
       :after vertico
       ;; :config
       ;;(setq marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
       :init (marginalia-mode))
   #+end_src

** Which-key
   #+begin_src emacs-lisp
     (use-package which-key
       :config
       (setq which-key-idle-delay 0.25
             which-key-max-description-length 45
             which-key-idle-secondary-delay 0.05
             which-key-show-remaining-keys t)
       :init (which-key-mode)
       ;; config for which-key output for repeat-mode maps
       ;; taken from https://gist.github.com/karthink/9f054dc8fba07fd117738bec31652a90
       ;; (slightly modified)
       :preface
       (setq --my-which-key-last-timer nil)
       (defun --my-which-key-reset-last-timer ()
         ;; `--my-which-key-last-timer' holds the timer returned by `run-with-idle-timer'
         ;; it is set on every key pressed while on repeat-mode, and reset to nil on both entry and exit
         ;; of repeat-mode through `repeat-mode-hook'
         (setq --my-which-key-last-timer nil))

       :hook ((repeat-mode . --my-which-key-reset-last-timer))
       :config
       (defun --my-which-key-repeat ()
         (unless (null --my-which-key-last-timer)
           (cancel-timer --my-which-key-last-timer))
         (when-let* ((cmd (or this-command real-this-command))
                     (keymap1 (repeat--command-property 'repeat-mode-map)))
           (run-with-idle-timer
            which-key-idle-delay nil
            (lambda ()
              (which-key--create-buffer-and-show
               nil (symbol-value keymap1))))))

       (defun --my-which-key-repeat-mode-dispatch ()
         (interactive)
         (setq this-command last-command)
         (when-let* (keymap2 (repeat--command-property 'repeat-map))
           (which-key--create-buffer-and-show
            nil (symbol-value keymap2))))

       (defun --my-which-key-repeat-mode-binding ()
         (when repeat-mode
           (when-let* ((rep-map-sym (or repeat-map (repeat--command-property 'repeat-map)))
                       (keymap3 (and (symbolp rep-map-sym) (symbol-value rep-map-sym))))
             (set-transient-map
              (make-composed-keymap
               (let ((map (make-sparse-keymap)))
                 (define-key map (kbd "C-h") #'--my-which-key-repeat-mode-dispatch)
                 map)
               keymap3)))))

       ;; for some odd reason `repeat-post-hook' and `repeat-pre-hook' are functions instead
       ;; of variables so functions on hook must be added through `advice-add'
       (advice-add 'repeat-post-hook :after #'--my-which-key-repeat)
       (advice-add 'repeat-post-hook :after #'--my-which-key-repeat-mode-binding)
       :bind ("C-c c w" . which-key-show-major-mode))

     (add-hook 'after-init-hook 'repeat-mode)
   #+end_src

** Avy
   #+begin_src emacs-lisp
     (use-package avy
       :defer t
       :bind
       ("C-:" . avy-goto-char-timer)
       ("C-c a l" . avy-goto-line)
       ("C-c a w" . avy-goto-subword-0)
       ("C-c a d" . avy-goto-word-0)
       ("C-c a s" . avy-goto-symbol-1))
   #+end_src

*** avy zap
#+begin_src emacs-lisp
  (use-package avy-zap
    :defer t
    :bind
    ("M-z" . avy-zap-to-char-dwim)
    ("M-Z" . avy-zap-up-to-char-dwim))
#+end_src

*** using treesit with avy
    #+begin_src emacs-lisp
      (use-package treesit-jump
        :after lsp
        :if (treesit-available-p)
        :straight (:host github :repo "dmille56/treesit-jump" :files ("*.el" "treesit-queries"))
        :init
        (defvar treesit-jump-map (make-sparse-keymap)
          "Keymap for treesit-jump commands.")
        :bind-keymap ("C-," . treesit-jump-map)
        :bind (:map treesit-jump-map
               ("j" . treesit-jump-jump)
               ("s" . treesit-jump-select)
               ("d" . treesit-jump-delete)
               ("p" . treesit-jump-parent-jump)
               ("t" . treesit-jump-transient)))
    #+end_src

** Embark
   #+begin_src emacs-lisp
     (use-package embark
       :ensure t
       :bind
       (("C-." . embark-act)         ;; pick some comfortable binding
        ;;("C-;" . embark-dwim)        ;; good alternative: M-.
        ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'
       :init
       ;; Optionally replace the key help with a completing-read interface
       (setq prefix-help-command #'embark-prefix-help-command)
       :config
       ;; Hide the mode line of the Embark live/completions buffers
       (add-to-list 'display-buffer-alist
                    '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                      nil
                      (window-parameters (mode-line-format . none)))))
   #+end_src

*** Embark consult
#+begin_src emacs-lisp
(use-package embark-consult
  :ensure t
  :after (embark consult)
  :demand t ; only necessary if you have the hook below
  ;; if you want to have consult previews as you move around an
  ;; auto-updating embark collect buffer
  :hook (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

*** Embark use whick-key like a key menu prompt
    #+begin_src emacs-lisp
      (defun embark-which-key-indicator ()
        "An embark indicator that displays keymaps using which-key.
      The which-key help message will show the type and value of the
      current target followed by an ellipsis if there are further
      targets."

        (when (bound-and-true-p which-key-mode)
          (lambda (&optional keymap targets prefix)
            (if (null keymap)
                (which-key--hide-popup-ignore-command)
              (which-key--show-keymap
               (if (eq (plist-get (car targets) :type) 'embark-become)
                   "Become"
                 (format "Act on %s '%s'%s"
                         (plist-get (car targets) :type)
                         (embark--truncate-target (plist-get (car targets) :target))
                         (if (cdr targets) "…" "")))
               (if prefix
                   (pcase (lookup-key keymap prefix 'accept-default)
                     ((and (pred keymapp) km) km)
                     (_ (key-binding prefix 'accept-default)))
                 keymap)
               nil nil t (lambda (binding)
                           (not (string-suffix-p "-argument" (cdr binding)))))))))

      (setq embark-indicators
            '(embark-which-key-indicator
              embark-highlight-indicator
              embark-isearch-highlight-indicator))

      (defun embark-hide-which-key-indicator (fn &rest args)
        "Hide the which-key indicator immediately when using the completing-read prompter."
        (which-key--hide-popup-ignore-command)
        (let ((embark-indicators
               (remq #'embark-which-key-indicator embark-indicators)))
          (apply fn args)))

      (advice-add #'embark-completing-read-prompter
                  :around #'embark-hide-which-key-indicator)
    #+end_src
** Yasnippet
   #+begin_src emacs-lisp
     (use-package yasnippet
       :defer t
       :hook (prog-mode . yas-minor-mode)
       :config
       (yas-reload-all))

     (use-package yasnippet-snippets
       :after yasnippet)
   #+end_src
** Linter
*** Flycheck
    #+begin_src emacs-lisp
      (use-package flycheck
        :hook (after-init . global-flycheck-mode)
        :config
        (add-to-list 'display-buffer-alist
                     `(,(rx bos "*Flycheck errors*" eos)
                       (display-buffer-reuse-window
                        display-buffer-in-side-window)
                       (side            . bottom)
                       (reusable-frames . visible)
                       (window-height   . 0.33))))
    #+end_src
**** flycheck inline
     #+begin_src emacs-lisp
       (use-package flycheck-inline
         :defer t
         :after flycheck-mode)
     #+end_src
** Consult and integrations
*** Consult
    #+begin_src emacs-lisp
      ;; Example configuration for Consult
      (use-package consult
        ;; Replace bindings. Lazily loaded by `use-package'.
        :bind (;; C-c bindings in `mode-specific-map'
               ("C-c M-x" . consult-mode-command)
               ("C-c h" . consult-history)
               ("C-c k" . consult-kmacro)
               ("C-c m" . consult-man)
               ("C-c i" . consult-info)
               ([remap Info-search] . consult-info)
               ;; C-x bindings in `ctl-x-map'
               ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
               ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
               ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
               ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
               ("C-x t b" . consult-buffer-other-tab)    ;; orig. switch-to-buffer-other-tab
               ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
               ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
               ;; Custom M-# bindings for fast register access
               ("M-#" . consult-register-load)
               ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
               ("C-M-#" . consult-register)
               ;; Other custom bindings
               ("M-y" . consult-yank-pop)                ;; orig. yank-pop
               ;; M-g bindings in `goto-map'
               ("M-g e" . consult-compile-error)
               ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
               ("M-g g" . consult-goto-line)             ;; orig. goto-line
               ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
               ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
               ("M-g m" . consult-mark)
               ("M-g k" . consult-global-mark)
               ("M-g i" . consult-imenu)
               ("M-g I" . consult-imenu-multi)
               ;; M-s bindings in `search-map'
               ("M-s d" . consult-find)                  ;; Alternative: consult-fd
               ("M-s c" . consult-locate)
               ("M-s g" . consult-grep)
               ("M-s G" . consult-git-grep)
               ("M-s r" . consult-ripgrep)
               ("M-s l" . consult-line)
               ("M-s L" . consult-line-multi)
               ("M-s k" . consult-keep-lines)
               ("M-s u" . consult-focus-lines)
               ;; Isearch integration
               ("M-s e" . consult-isearch-history)
               :map isearch-mode-map
               ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
               ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
               ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
               ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
               ;; Minibuffer history
               :map minibuffer-local-map
               ("M-s" . consult-history)                 ;; orig. next-matching-history-element
               ("M-r" . consult-history))                ;; orig. previous-matching-history-element

        ;; Enable automatic preview at point in the *Completions* buffer. This is
        ;; relevant when you use the default completion UI.
        :hook (completion-list-mode . consult-preview-at-point-mode)

        ;; The :init configuration is always executed (Not lazy)
        :init

        ;; Tweak the register preview for `consult-register-load',
        ;; `consult-register-store' and the built-in commands.  This improves the
        ;; register formatting, adds thin separator lines, register sorting and hides
        ;; the window mode line.
        (advice-add #'register-preview :override #'consult-register-window)
        (setq register-preview-delay 0.5)

        ;; Use Consult to select xref locations with preview
        (setq xref-show-xrefs-function #'consult-xref
              xref-show-definitions-function #'consult-xref)

        ;; Configure other variables and modes in the :config section,
        ;; after lazily loading the package.
        :config

        ;; Optionally configure preview. The default value
        ;; is 'any, such that any key triggers the preview.
        ;; (setq consult-preview-key 'any)
        ;; (setq consult-preview-key "M-.")
        ;; (setq consult-preview-key '("S-<down>" "S-<up>"))
        ;; For some commands and buffer sources it is useful to configure the
        ;; :preview-key on a per-command basis using the `consult-customize' macro.
        (consult-customize
         consult-theme :preview-key '(:debounce 0.2 any)
         consult-ripgrep consult-git-grep consult-grep consult-man
         consult-bookmark consult-recent-file consult-xref
         consult--source-bookmark consult--source-file-register
         consult--source-recent-file consult--source-project-recent-file
         ;; :preview-key "M-."
         :preview-key '(:debounce 0.4 any))

        ;; Optionally configure the narrowing key.
        ;; Both < and C-+ work reasonably well.
        (setq consult-narrow-key "<") ;; "C-+"

        ;; Optionally make narrowing help available in the minibuffer.
        ;; You may want to use `embark-prefix-help-command' or which-key instead.
        ;; (keymap-set consult-narrow-map (concat consult-narrow-key " ?") #'consult-narrow-help)
      )
    #+end_src

*** Consult flycheck
    #+begin_src emacs-lisp
      (use-package consult-flycheck
        :defer t
        :after (flycheck consult))
    #+end_src

*** Consult yasnippet
    #+begin_src emacs-lisp
      (use-package consult-yasnippet
        :defer t
        :after (yasnippet consult))
    #+end_src

*** Consult org-roam
    #+begin_src emacs-lisp
      (use-package consult-org-roam
        :defer t
        :after org-roam
        :init
        (require 'consult-org-roam)
        ;; Activate the minor mode
        (consult-org-roam-mode 1)
        :custom
        ;; use `ripgrep` for searching with `consult-org-roam-search`
        (consult-org-roam-grep-func #'consult-ripgrep)
        ;; custom narrow key for `consult-buffer`
        (consult-org-roam-narrow-key ?r)
        ;; display org-roam buffers right after non-org-roam buffers
        ;; in consult-buffer (and not down at the bottom)
        (consult-org-roam-buffer-after-buffers t)
        :config
        ;; eventually suppress previewing for certain functions
        (consult-customize
         consult-org-roam-forward-links
         :preview-key "M-.")
        :bind
        ;; define some convenient keybindings as an addition
        ("C-c n e" . consult-org-roam-file-find)
        ("C-c n b" . consult-org-roam-backlinks)
        ("C-c n B" . consult-org-roam-backlinks-recursive)
        ("C-c n l" . consult-org-roam-forward-links)
        ("C-c n r" . consult-org-roam-search))
        #+end_src
** LLM
*** Copilot
   #+begin_src emacs-lisp
     (defun my/copilot-tab ()
       (interactive)
       (or (copilot-accept-completion)
           (indent-for-tab-command)))

     (use-package copilot
       :defer t
       :straight (:host github :repo "copilot-emacs/copilot.el")
       :custom
       (copilot-idle-delay 30)
       :config
       (add-to-list 'copilot-major-mode-alist '("rust-ts-mode" . "rust"))
       (define-key copilot-completion-map (kbd "<tab>") 'copilot-accept-completion)
       :bind
       (:map prog-mode-map
             ("C-c C-o RET" . global-copilot-mode))
       (:map copilot-mode-map
             ("<TAB>" . my/copilot-tab)
             ("C-c C-o n" . copilot-next-completion)
             ("C-c C-o SPC" . copilot-complete)
             ("C-c C-o p" . copilot-previous-completion)
             ("C-c C-o a" . copilot-accept-completion)
             ("C-c C-o C-a l" . copilot-accept-completion-by-line)
             ("C-c C-o C-a w" . copilot-accept-completion-by-word)))
   #+end_src
*** aidermacs
#+begin_src emacs-lisp
  (use-package aidermacs
    :bind (("C-;" . aidermacs-transient-menu))
    :config
    (setenv "ANTHROPIC_API_KEY" (shell-command-to-string "echo -n $ANTHROPIC_API_KEY"))
    (setenv "OPENROUTER_API_KEY" (shell-command-to-string "echo -n $OPENROUTER_API_KEY"))
    :custom
    (aidermacs-auto-commits nil)
    (aidermacs-default-chat-mode 'architect)
    (aidermacs-watch-files t)
    (aidermacs-backend 'comint)
    (aidermacs-show-diff-after-change t)
    (aidermacs-default-model "anthropic/claude-opus-4-20250514")
    (aidermacs-architect-model "anthropic/claude-sonnet-4-20250514"))
#+end_src
**** COMMENT vterm
#+begin_src emacs-lisp
  (use-package vterm
    :defer t)
#+end_src
* Appearance
** font
*** Set font
    #+begin_src emacs-lisp
      (defconst ui-font
        "Atkinson Hyperlegible Mono"
        "Font for ui faces")

      (defconst modeline-font
        "Caffeine Mono"
        "font used by the modeline")

      (defconst org-font
        "Margem Rounded Test"
        "Font used on org-mode")

      (defconst programming-font
        "Dank Mono"
        "Font for programming faces")

      (defconst alternative-programming-font
        "Dank Mono"
        "Font for alternative faces")

      ;; default face for ui
      (set-face-attribute 'default nil
                          :font ui-font
                          :height 130)
      ;; face for programming
      (add-hook 'prog-mode-hook
                (lambda ()
                  (face-remap-add-relative 'default
                                          :family programming-font
                                          :height 130)))
      (add-hook 'after-init-hook #'global-auto-composition-mode)
    #+end_src
*** Fix org mode tables
    #+begin_src emacs-lisp
      (set-face-attribute 'org-table nil :inherit 'fixed-pitch)
    #+end_src
*** ligatures
    #+begin_src emacs-lisp
      (use-package ligature
        :straight (:host github :repo "mickeynp/ligature.el")
        :hook (after-init . global-ligature-mode)
        :config
        (ligature-set-ligatures 't '("www"))
        (ligature-set-ligatures
         'prog-mode
         '("-->" "//" "/**" "/*" "*/" "<!--" ":=" "->>" "<<-" "->" "<-"
           "<=>" "==" "!=" "<=" ">=" "=:=" "!==" "&&" "||" "..." ".."
           "|||" "///" "&&&" "===" "++" "--" "=>" "|>" "<|" "||>" "<||"
           "|||>" "<|||" ">>" "<<" "::=" "|]" "[|" "{|" "|}"
           "[<" ">]" ":?>" ":?" "/=" "[||]" "!!" "?:" "?." "::"
           "+++" "??" "###" "##" ":::" "####" ".?" "?=" "=!=" "<|>"
           "<:" ":<" ":>" ">:" "***" ";;" "/==" ".=" ".-" "__" ;; "<>"
           "=/=" "<-<" "<<<" ">>>" "<=<" "<<=" "<==" "<==>" "==>" "=>>"
           ">=>" ">>=" ">>-" ">-" "<~>" "-<" "-<<" "=<<" "---" "<-|"
           "<=|" "/\\" "\\/" "|=>" "|~>" "<~~" "<~" "~~" "~~>" "~>"
           "<$>" "<$" "$>" "<+>" "<+" "+>" "<*>" "<*" "*>" "</>" "</" "/>"
           "<->" "..<" "~=" "~-" "-~" "~@" "^=" "-|" "_|_" "|-" "||-"
           "|=" "||=" "#{" "#[" "]#" "#(" "#?" "#_" "#_(" "#:" "#!" "#="
           "&=")))
    #+end_src
** add frame borders and window dividers
   #+begin_src emacs-lisp
     (modify-all-frames-parameters
      '((right-divider-width . 0)
        (internal-border-width . 0)))
   #+end_src
** icons
   #+begin_src emacs-lisp
     (use-package all-the-icons
       :defer t)
     (use-package nerd-icons
       :defer t)
     (use-package nerd-icons-completion
       :defer t
       :after marginalia
       :config
       (nerd-icons-completion-mode)
       (add-hook 'marginalia-mode-hook #'nerd-icons-completion-marginalia-setup))

     (use-package all-the-icons-nerd-fonts
       :defer t
       :straight
       (all-the-icons-nerd-fonts :host github :repo "mohkale/all-the-icons-nerd-fonts")
       :after all-the-icons
       :demand t
       :config
       (all-the-icons-nerd-fonts-prefer))
   #+end_src
** themes
*** downloading themes
**** Doom themes
     #+begin_src emacs-lisp
       (use-package doom-themes
         :defer t
         :config
         (setq doom-themes-enable-bold t
               ;; doom-themes-treemacs-theme "doom-colors"
               doom-themes-enable-italic t)
         (doom-themes-treemacs-config)
         (doom-themes-org-config))
     #+end_src
**** kaolin themes
     #+begin_src emacs-lisp
       (use-package kaolin-themes
         :init
         (setq kaolin-themes-bold t
               kaolin-themes-italic t
               kaolin-themes-italic-comments t
               kaolin-themes-distinct-parentheses t
               kaolin-themes-distinct-fringe nil
               kaolin-themes-comments-style 'alt
               kaolin-themes-hl-line-colored t
               kaolin-themes-underline t)
         :defer t)
     #+end_src
**** spacemacs themes
     #+begin_src emacs-lisp
       (use-package spacemacs-theme
         :defer t
         :config
         (setq spacemacs-theme-comment-bg nil
               spacemacs-theme-keyword-italic t
               spacemacs-theme-org-bold t
               spacemacs-theme-comment-italic t))
     #+end_src
*** loading theme
    #+begin_src emacs-lisp
      (load "~/.emacs.d/my-themes/dark-tale-theme.el")
      (load "~/.emacs.d/my-themes/bright-tale-theme.el")

      ;; Define variables for your themes
      (defvar my-gui-theme 'dark-tale
        "The theme to use for graphical Emacs frames.")
      (defvar my-cli-theme 'dark-tale
        "The theme to use for terminal (CLI) Emacs frames.")

      (defun my/apply-theme ()
        "Apply theme based on display type."
        (if (display-graphic-p)
            (load-theme my-gui-theme t)
          (load-theme my-cli-theme t)))

      (my/apply-theme)

      ;; Reapply theme when creating new frames (useful for emacsclient)
      (add-hook 'after-make-frame-functions
                (lambda (frame)
                  (select-frame frame)
                  (my/apply-theme)))
    #+end_src
** UI
*** Splash screen
    #+begin_src emacs-lisp
      (setq inhibit-startup-screen t)
    #+end_src
*** Scratch buffer message
    #+begin_src emacs-lisp
      (setq initial-scratch-message nil
            inhibit-startup-echo-area-message t)
    #+end_src
*** Scroll bar
    #+begin_src emacs-lisp
      (scroll-bar-mode -1)
    #+end_src
*** Menu bar
    #+begin_src emacs-lisp
      (menu-bar-mode -1)
    #+end_src
*** Tool bar
    #+begin_src emacs-lisp
      (tool-bar-mode -1)
    #+end_src
*** Cursor type
    #+begin_src emacs-lisp
      (setq-default cursor-type '(bar . 1))
      (setq-default blink-cursor-delay 5)
      (setq-default blink-cursor-interval 0.75)
      (setq-default cursor-in-non-selected-windows '(hbar . 1))
    #+end_src
*** auto show and hide current line
    #+begin_src emacs-lisp
      (use-package hl-line
        :ensure nil
        :init
        (defvar my-hl-line-ignored-modes
          '(treemacs-mode dired-mode magit-mode)
          "List of major modes where the idle hl-line behavior should be ignored.")

        (defvar my-hide-hl-line-timer nil
          "Timer to show the hl-line after a certain idle time.")

        (defun my-show-hl-line ()
          "Show the hl-line by enabling `hl-line-mode` if not in ignored modes."
          (unless (or hl-line-mode
                      (member major-mode my-hl-line-ignored-modes))
            (hl-line-mode 1)))

        (defun my-hide-hl-line ()
          "Hide the hl-line by disabling `hl-line-mode`."
          (when (and hl-line-mode
                     (not (member major-mode my-hl-line-ignored-modes)))
            (hl-line-mode -1)))

        (defun my-start-idle-timer ()
          "Start the idle timer to show the hl-line after a certain time."
          (when (and my-hide-hl-line-timer
                     (not (member major-mode my-hl-line-ignored-modes)))
            (cancel-timer my-hide-hl-line-timer))  ;; Cancel any existing timer
          (unless (member major-mode my-hl-line-ignored-modes)
            (setq my-hide-hl-line-timer (run-with-idle-timer 5 nil #'my-show-hl-line))))

        (defun my-hl-line-reset-on-command ()
          "Hide the hl-line and reset the idle timer when a command is executed."
          (unless (member major-mode my-hl-line-ignored-modes)
            (my-hide-hl-line)
            (my-start-idle-timer)))

        (defun my-toggle-hl-line ()
          "Set up hooks to hide/show the hl-line based on idle time and input."
          (add-hook 'post-command-hook #'my-hl-line-reset-on-command)
          (my-start-idle-timer))
        :config
        (my-toggle-hl-line))
    #+end_src
*** highlight todo
    #+begin_src emacs-lisp
      (use-package hl-todo
        :hook (after-init . global-hl-todo-mode))

      (define-key prog-mode-map (kbd "C-|") (lambda ()
                                              (interactive)
                                              (hl-todo-insert "TODO(matheus-consoli): ")))
    #+end_src
*** Only highlight text region
    #+begin_src emacs-lisp
      (set-face-attribute 'region nil :extend nil)
    #+end_src
*** Line numbers
**** Hook
     #+begin_src emacs-lisp
       (add-hook 'prog-mode-hook 'display-line-numbers-mode)
     #+end_src
**** Format
     #+begin_src emacs-lisp
       (fringe-mode '(20 . 20))
     #+end_src
*** fix color display when loading emacs in terminal
    #+begin_src emacs-lisp
      (defun enable-256color-term ()
        (interactive)
        (load-library "term/xterm")
        (terminal-init-xterm))

      (unless (display-graphic-p)
        (if (string-suffix-p "256color" (getenv "TERM"))
          (enable-256color-term)))
    #+end_src
** tabs
*** tab bar mode
#+begin_src emacs-lisp
  (defun my/tab-bar-project-name ()
    "Return project name for tab, fallback to buffer name."
    (if-let ((project (project-current)))
        (project-name project)
      (buffer-name)))

  (use-package tab-bar
    :hook (after-init . tab-bar-mode)
    :bind
    (:map tab-bar-map
          ("<next>" . tab-bar-switch-to-next-tab)
          ("<prior>" . tab-bar-switch-to-prev-tab))
    :config
    (setq tab-bar-new-tab-choice t
          tab-bar-new-tab-to 'rightmost
          tab-bar-close-button-show nil
          tab-bar-show 0
          tab-bar-new-button-show nil
          tab-bar-tab-name-function #'my/tab-bar-project-name
          tab-bar-tab-name-truncated-max 30
          tab-bar-tab-hints nil
          tab-bar-auto-width t
          tab-bar-auto-width-max '((160) 20)))
#+end_src
**** only show when there are projects opened
#+begin_src emacs-lisp
  (defun my/buffer-has-project-p ()
    "Return non-nil if current buffer belongs to a project."
    (project-current))

  (defun my/advice-tab-bar-new-tab (orig-fun &rest args)
    "Only create new tab if current buffer has a project."
    (when (my/buffer-has-project-p)
      (apply orig-fun args)))

  (defun my/setup-project-only-tabs ()
    "Configure tabs to only show for projects."
    ;; Hide tab-bar initially
    (setq tab-bar-show 0)

    ;; Advice tab creation functions
    (advice-add 'tab-bar-new-tab :around #'my/advice-tab-bar-new-tab)
    (advice-add 'tab-bar-new-tab-to :around #'my/advice-tab-bar-new-tab)

    ;; Show tab-bar only when we have project tabs
    (add-hook 'tab-bar-tab-post-open-functions
              (lambda (&rest _)
                (when (> (length (tab-bar-tabs)) 1)
                  (setq tab-bar-show 0))))

    ;; Close non-project tabs on startup
    (run-with-idle-timer 0.1 nil
                         (lambda ()
                           (let ((tabs (tab-bar-tabs)))
                             (dolist (tab tabs)
                               (let ((tab-name (alist-get 'name tab)))
                                 (unless (and tab-name
                                              (not (string-match-p "^\\*.*\\*$" tab-name))
                                              (not (string= tab-name "Default")))
                                   (when (> (length tabs) 1)
                                     (tab-bar-close-tab (1+ (cl-position tab tabs)))))))))))

  ;; Add this to your config
  (add-hook 'after-init-hook #'my/setup-project-only-tabs)
#+end_src
*** project tab groups
#+begin_src emacs-lisp
  (use-package project-tab-groups
    :config
    (with-eval-after-load 'project
      (add-to-list 'project-switch-commands '(magit-project-status "Magit") t)
      (keymap-set project-prefix-map "m" #'magit-project-status))
    (project-tab-groups-mode 1))
#+end_src
*** tab spaces
#+begin_src emacs-lisp
  (use-package tabspaces
    :straight (:type git :host github :repo "mclear-tools/tabspaces")
    :hook (after-init . tabspaces-mode)
    :commands (tabspaces-switch-or-create-workspace
               tabspaces-open-or-create-project-and-workspace)
    :custom
    (tabspaces-use-filtered-buffers-as-default t)
    (tabspaces-session-project-session-store "~/.emacs.d/tabspaces-sessions/")
    (tabspaces-default-tab "Default")
    (tabspaces-remove-to-default t)
    (tabspaces-initialize-project-with-todo t)
    (tabspaces-todo-file-name "project-todo.org")
    ;; sessions
    (tabspaces-session t)
    (tabspaces-session-auto-restore nil)
    :config
    ;; Filter Buffers for Consult-Buffer
    (with-eval-after-load 'consult
      ;; hide full buffer list (still available with "b" prefix)
      (consult-customize consult--source-buffer :hidden t :default nil)
      ;; set consult-workspace buffer list
      (defvar consult--source-workspace
        (list :name     "Workspace Buffers"
              :narrow   ?w
              :history  'buffer-name-history
              :category 'buffer
              :state    #'consult--buffer-state
              :default  t
              :items    (lambda () (consult--buffer-query
                                    :predicate #'tabspaces--local-buffer-p
                                    :sort 'visibility
                                    :as #'buffer-name)))

        "Set workspace buffer list for consult-buffer.")
      (add-to-list 'consult-buffer-sources 'consult--source-workspace)))
#+end_src
*** tabs
**** hide special tabs
#+begin_src emacs-lisp
  (defun centaur-tabs-hide-tab (x)
    "Do no to show buffer X in tabs."
    (let ((name (format "%s" x)))
      (message "%s" name)
      (or
       ;; Current window is not dedicated window.
       (window-dedicated-p (selected-window))

       ;; Buffer name not match below blocklist.
       (string-prefix-p "*epc" name)
       (string-prefix-p "*helm" name)
       (string-prefix-p "*Helm" name)
       (string-prefix-p "*Compile-Log*" name)
       (string-prefix-p "*lsp" name)
       (string-prefix-p "*company" name)
       (string-prefix-p "*Flycheck" name)
       (string-prefix-p "*tramp" name)
       (string-prefix-p " *Mini" name)
       (string-prefix-p "*help" name)
       (string-prefix-p "*straight" name)
       (string-prefix-p " *temp" name)
       (string-prefix-p "*Help" name)
       (string-prefix-p "*mybuf" name)
       (string-prefix-p "*Warnings" name)
       (string-prefix-p "*aidermacs" name)
       (string-prefix-p "*eldoc" name)

       ;; Is not magit buffer.
       (and (string-prefix-p "magit" name)
            (not (file-name-extension name))))))
#+end_src
**** centaur tabs
#+begin_src emacs-lisp
  (use-package centaur-tabs
    :hook (after-init . centaur-tabs-mode)
    :config
    (centaur-tabs-headline-match)
    (centaur-tabs-change-fonts alternative-programming-font 90)
    :bind
    (:map centaur-tabs-mode-map
          (([remap next-buffer] . centaur-tabs-forward)
           ([remap previous-buffer] . centaur-tabs-backward)
           ("C-c t j" . centaur-tabs-ace-jump)
           ("C-<prior>" . centaur-tabs-backward)
           ("C-<next>" . centaur-tabs-forward)))
    :custom
    (centaur-tabs-height 25)
    (centaur-tabs-style "alternate")
    ;;(centaur-tabs-hide-tab-function 'centaur-tabs-hide-tab)
    (centaur-tabs-set-bar 'under)
    (x-underline-at-descent-line t) ;; to correctly display the icon
    (centaur-tabs-cycle-scope 'tabs)
    (centaur-tabs-gray-out-icons 'buffer)
    (centaur-tabs-set-icons t)
    (centaur-tabs-icon-type 'all-the-icons)
    (centaur-tabs-gray-out-icons 'buffer)
    (centaur-tabs-modified-marker t)
    (centaur-tabs-enable-key-bindings t))
#+end_src
***** hide
#+begin_src emacs-lisp
  (dolist (hook '(special-mode-hook
                  aidermacs-comint-mode-hook
                  aidermacs-vterm-mode-hook))
    (add-hook hook #'centaur-tabs-local-mode))
#+end_src
** treemacs
   #+begin_src emacs-lisp
     (use-package treemacs
       :defer t
       :custom
       (treemacs-file-follow-delay 3)
       (treemacs-expand-after-init nil)
       (treemacs-file-follow-delay 1.5)
       :config
       (treemacs-resize-icons 11)
       (treemacs-git-commit-diff-mode t)
       (treemacs-fringe-indicator-mode 'always)
       (treemacs-follow-mode t)
       (treemacs-project-follow-mode nil)
       (treemacs-filewatch-mode t)
       (treemacs-peek-mode t)
       (treemacs-resize-icons 11)
       :bind
       (:map global-map
             ("C-c ; ;" . treemacs)
             ("C-c ; B" . treemacs-bookmark)
             ("C-c ; f" . treemacs-find-file)
             ("C-c ; g" . treemacs-find-tag)))
   #+end_src
*** treemacs extensions
    #+begin_src emacs-lisp
      (use-package treemacs-magit
        :defer t
        :after (treemacs magit))

      (use-package treemacs-nerd-icons
        :defer t
        :after (treemacs))

      (use-package treemacs-tab-bar
        :defer t
        :after (treemacs)
        :config (treemacs-set-scope-type 'Tabs))

      ;; (use-package lsp-treemacs
      ;;   :defer t
      ;;   :after (treemacs lsp)
      ;;   :commands (lsp-treemacs-symbols lsp-treemacs-errors-list toggle-lsp-treemacs-modes)
      ;;   :init
      ;;   (defun toggle-lsp-treemacs-modes ()
      ;;     "Toggle both `lsp-treemacs-symbols` and `lsp-treemacs-error-list` modes."
      ;;     (interactive)
      ;;     ;; Toggle lsp-treemacs-symbols
      ;;     (if (get-buffer lsp-treemacs-symbols-buffer-name)
      ;;         (kill-buffer lsp-treemacs-symbols-buffer-name) ; this closes it if open
      ;;       (lsp-treemacs-symbols)) ; this opens it if closed
      ;;     ;; Toggle lsp-treemacs-error-list
      ;;     (if (get-buffer lsp-treemacs-errors-buffer-name)
      ;;         (kill-buffer lsp-treemacs-errors-buffer-name) ; this closes it if open
      ;;       (lsp-treemacs-errors-list))) ; this opens it if closed
      ;;   :config
      ;;   (setq
      ;;    lsp-treemacs-error-list-expand-depth 1
      ;;    lsp-treemacs-call-hierarchy-expand-depth 1
      ;;    lsp-treemacs-error-list-current-project-only t
      ;;    lsp-treemacs-symbols-position-params '((side . right)
      ;;                                           (slot . 1)
      ;;                                           (window-width . 40))
      ;;    lsp-treemacs-errors-position-params '((side . right)
      ;;                                          (slot . 2)
      ;;                                          (window-width . 40)))
      ;;   (lsp-treemacs-sync-mode 1)
      ;;   :bind (:map lsp-mode-map
      ;;               ("C-c l g m" . toggle-lsp-treemacs-modes)))
    #+end_src
** modeline
   #+begin_src emacs-lisp
     (use-package doom-modeline
       :config
       (use-package async :defer t)
       (use-package ghub :defer t)
       (setq
        auth-sources '("~/.authinfo.gpg")
        doom-modeline-height 30
        doom-modeline-bar-width 8
        doom-modeline-time-clock-size 0.4
        doom-modeline-hud t
        doom-modeline-github nil
        doom-modeline-github-interval (* 30 60)
        doom-modeline-enable-word-count t
        doom-modeline-buffer-encoding t
        doom-modeline-support-imenu t
        doom-modeline-irc nil
        doom-modeline-position-line-format '("L%l")
        doom-modeline-percent-position '(-3 "%p")
        doom-modeline-position-column-line-format '("%l:%c")
        doom-modeline-buffer-file-name-style 'relative-to-project
        doom-modeline-gnus nil
        doom-modeline-icon nil ;; remove icons
        doom-modeline-time-icon nil
        doom-modeline-buffer-modification-icon nil)
       :hook (after-init . doom-modeline-mode))
   #+end_src
*** Clock
    #+BEGIN_SRC emacs-lisp
      (setq-default display-time-default-load-average nil)
      (setq display-time-format " %I:%M\t")
      (display-time-mode 1)
    #+END_SRC
*** toggle modeline when idle for some time
#+begin_src emacs-lisp
  ;; (use-package hide-mode-line
  ;;   :config
  ;;   (defvar my-hide-modeline-timer nil
  ;;     "Timer to show the modeline after a certain idle time.")

  ;;   (defun my-show-modeline ()
  ;;     "Show the modeline by disabling `hide-mode-line-mode`."
  ;;     (when hide-mode-line-mode
  ;;       (hide-mode-line-mode -1))
  ;;     (force-mode-line-update t))

  ;;   (defun my-hide-modeline ()
  ;;     "Hide the modeline by enabling `hide-mode-line-mode`."
  ;;     (unless hide-mode-line-mode
  ;;       (hide-mode-line-mode 1))
  ;;     (force-mode-line-update t))

  ;;   (defun my-start-idle-timer ()
  ;;     "Start the idle timer to show the modeline after a certain time."
  ;;     (when my-hide-modeline-timer
  ;;       (cancel-timer my-hide-modeline-timer))  ;; Cancel any existing timer
  ;;     (setq my-hide-modeline-timer (run-with-idle-timer 3 nil #'my-show-modeline)))

  ;;   (defun my-reset-on-command ()
  ;;     "Hide the modeline and reset the idle timer when a command is executed."
  ;;     (my-hide-modeline)
  ;;     (my-start-idle-timer))

  ;;   (defun my-toggle-modeline ()
  ;;     "Set up hooks to hide/show the modeline based on idle time and input."
  ;;     (add-hook 'post-command-hook #'my-reset-on-command)
  ;;     (my-start-idle-timer))

  ;;   (my-toggle-modeline))
#+end_src
*** hide modeline for some modes
#+begin_src emacs-lisp
  (defun my/hide-modeline ()
    "Hide the mode-line in the current buffer"
    (setq-local mode-line-format nil))

  (dolist (hook '(aidermacs-comint-mode-hook
                  aidermacs-vterm-mode-hook))
    (add-hook hook #'my/hide-modeline))
#+end_src
** custom set faces
   #+begin_src emacs-lisp
          (set-face-attribute 'mode-line nil
                              :inherit 'default
                              :family modeline-font
                              :height 110
                              :box nil)

          (set-face-attribute 'mode-line-active nil
                              :inherit 'mode-line
                              :box nil)

          (set-face-attribute 'mode-line-inactive nil
                              :inherit 'mode-line-active
                              :box nil)

          (set-face-attribute 'font-lock-comment-face nil
                              :font programming-font
                              :slant 'italic
                              :height 110)

          (set-face-attribute 'tab-bar nil
                              :font alternative-programming-font
                              :height 100)


          (defun set-face-for-tab-bar-tab (_theme)
            (set-face-attribute 'tab-bar-tab nil
                                :box `(:line-width (7 . -1)
                                              :style nil
                                              :color ,(face-attribute 'tab-bar-tab :background)))
            (set-face-attribute 'tab-bar-tab-inactive nil
                                :box `(:line-width (7 . -1)
                                              :style nil
                                              :color ,(face-attribute 'tab-bar-tab-inactive :background))))

          (add-hook 'enable-theme-functions #'set-face-for-tab-bar-tab)

          (with-eval-after-load 'blamer
            (set-face-attribute 'blamer-face nil
                                :family programming-font
                                :height 100
                                :italic t))

          (dolist (face '(window-divider
                          window-divider-first-pixel
                          window-divider-last-pixel))
            (face-spec-reset-face face)
            (set-face-foreground face (face-attribute 'default :background))
            (set-face-background face (face-attribute 'default :background)))
          (set-face-background 'fringe (face-attribute 'default :background))
   #+end_src
* Org
** install
   #+begin_src emacs-lisp
     (use-package org
       :defer t)
   #+end_src
** org modern
#+begin_src emacs-lisp
  (use-package org-modern
    :hook (org-mode . org-modern-mode))
#+end_src
** custom faces
*** variable pitch
    #+begin_src emacs-lisp
      (use-package org-variable-pitch
        :hook (org-mode . variable-pitch-mode))
    #+end_src
*** fixed pitch
    #+begin_src emacs-lisp
      (require 'org-indent)
      (set-face-attribute 'fixed-pitch nil :family alternative-programming-font :height 120)
      (set-face-attribute 'font-lock-doc-face nil :inherit 'font-lock-string-face :height 120)
      (set-face-attribute 'org-block nil :inherit 'fixed-pitch)
      (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)
      (set-face-attribute 'org-code nil :inherit '(shadow fixed-pitch))
      (set-face-attribute 'org-document-info-keyword nil :inherit '(shadow fixed-pitch))
      (set-face-attribute 'org-formula nil  :inherit 'fixed-pitch)
      (set-face-attribute 'org-indent nil :inherit '(org-hide fixed-pitch))
      (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
      (set-face-attribute 'org-property-value nil :inherit 'fixed-pitch)
      (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
      (set-face-attribute 'org-table nil  :inherit 'fixed-pitch)
      (set-face-attribute 'org-tag nil :inherit '(shadow fixed-pitch) :weight 'bold :height 0.8)
      (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
      (set-face-attribute 'variable-pitch nil :family org-font :height 130)
    #+end_src

*** column views
    #+begin_src emacs-lisp
      (set-face-attribute 'org-column nil :background nil)
      (set-face-attribute 'org-column-title nil :background nil)
    #+end_src
** org superstar
   #+begin_src emacs-lisp
     ;; org-superstar needs this way
     (setq org-hide-leading-stars nil)

     (use-package org-superstar
       :after org
       :init
       (setq org-superstar-headline-bullets-list '(?● ?○)
             ;; fancy todo headings
             org-superstar-special-todo-items t
             ;; i use my own
             org-superstar-prettify-item-bullets nil)
       :hook (org-mode . org-superstar-mode))

     ;; This line is necessary.
     (setq org-superstar-leading-bullet ?\s)
     ;; If you use Org Indent you also need to add this, otherwise the
     ;; above has no effect while Indent is enabled.
     (setq org-indent-mode-turns-on-hiding-stars nil)
   #+end_src

** make invisible parts visible
   #+begin_src emacs-lisp
     (use-package org-appear
       :hook (org-mode . org-appear-mode))
   #+end_src
** org mode as the *scratch* buffer
   #+begin_src emacs-lisp
     (setq initial-major-mode 'org-mode)
   #+end_src
** pretty checkboxes
   https://jft.home.blog/2019/07/17/use-unicode-symbol-to-display-org-mode-checkboxes/
   #+begin_src emacs-lisp
     (defface org-checkbox-done-text
       '((t (:foreground "#71696A" :strike-through t)))
       "Face for the text part of a checked org-mode checkbox.")

     (font-lock-add-keywords
      'org-mode
      `(("^[ \t]*\\(?:[-+*]\\|[0-9]+[).]\\)[ \t]+\\(\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\\)?\\[\\(?:X\\|\\([0-9]+\\)/\\2\\)\\][^\n]*\n\\)"
         1 'org-checkbox-done-text prepend))
      'append)

     (add-hook 'org-mode-hook (lambda ()
                                "Beautify Org Checkbox Symbol"
                                (push '("[ ]" . "") prettify-symbols-alist)
                                (push '("[X]" . "" ) prettify-symbols-alist)
                                (push '("[-]" . "" ) prettify-symbols-alist)
                                (prettify-symbols-mode)))
   #+end_src
** pretty bullet list
   #+begin_src emacs-lisp
     (font-lock-add-keywords 'org-mode
                             '(("^ *\\([-]\\) "
                                (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
   #+end_src
** centralized
   #+begin_src emacs-lisp
     (use-package olivetti
       :hook
       (org-mode . olivetti-mode)
       (markdown-mode . olivetti-mode)
       (prog-mode . olivetti-mode)
       :config (setq-default olivetti-body-width 170))

     (setq-default default-justification 'full)
   #+end_src
** org-roam
*** sqlite3
#+begin_src emacs-lisp
    (use-package sqlite3
      :defer t)
#+end_src
*** Load org-fold
    #+begin_src emacs-lisp
      (require 'org-fold)
    #+end_src
*** Install it
    #+begin_src emacs-lisp
      (use-package org-roam
        :defer t
        :bind (("C-c b f" . org-roam-node-find)
               ("C-c b i" . org-roam-node-insert)
               ("C-c b c" . org-roam-capture)
               ("C-c b g" . org-roam-graph)
               ("C-c b d" . org-roam-dailies-capture-today)
               ("C-c b D" . org-roam-dailies-goto-today)
               ("C-c b y" . org-roam-dailies-goto-previous))
        :config
        (cl-defmethod org-roam-node-keywords ((node org-roam-node))
          "Return the currently set category for the NODE."
          (cdr (assoc-string "KEYWORDS" (org-roam-node-properties node))))
        (cl-defmethod org-roam-node-authors ((node org-roam-node))
          "Return the currently set category for the NODE."
          (cdr (assoc-string "AUTHORS" (org-roam-node-properties node))))
        (setq org-roam-node-display-template
              (concat "${title:*} "
                      (propertize "${tags:15}" 'face 'org-tag)
                      (propertize "${keywords:20}" 'face 'org-tag)
                      (propertize "${authors:15}" 'face 'org-tag)))
        (org-roam-db-autosync-mode))
    #+end_src
*** Config
    #+begin_src emacs-lisp
      (setq
       org-roam-directory (file-truename "~/projects/brainiac/")
       org-roam-db-location (file-truename "~/projects/brainiac/org-roam.db")
       org-roam-dailies-directory "dailies/")
    #+end_src
*** Templates
**** Dailies
     #+begin_src emacs-lisp
       (setq
        org-roam-dailies-capture-templates
        '(("d" "default" entry
           "\n\n* %<%I:%M %p>: %?"
           :target (file+head "%<%Y-%m-%d>.org"
                              "#+TITLE: %<%Y-%m-%d>\n"))))
     #+end_src
**** Custom templates
***** Uncategorized
      #+begin_src emacs-lisp
        (setq org-roam-capture-templates
              '(("u" "uncategorized" plain
                 "* %?"
                 :target (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                                    "#+FILETAGS: :uncategorized:\n#+TITLE: ${title}\n#+DATE: %U\n\n")
                 :unnarrowed t)))
      #+end_src
***** Book
      #+begin_src emacs-lisp
        (add-to-list 'org-roam-capture-templates
                     '("k" "book" plain
                       "\n\n* Contents%?"
                       :target (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                                          ":PROPERTIES:\n:AUTHORS: %^{authors}\n:KEYWORDS: %^{keywords}\n:END:\n\n#+FILETAGS: :book:\n#+TITLE: ${title}\n#+DATE: %U\n")
                       :unnarrowed t))
      #+end_src
***** Paper
      #+begin_src emacs-lisp
        (add-to-list 'org-roam-capture-templates
                     '("p" "paper" plain
                       "* Reference\nYear: %^{year}\nLink: %^{Link}\n\n* Abstract\n%?"
                       :target (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                                          ":PROPERTIES:\n:AUTHORS: %^{authors}\n:KEYWORDS: %^{keywords}\n:END:\n\n#+FILETAGS: :paper:\n#+TITLE: ${title}\n#+DATE: %U\n")
                       :unnarrowed t))
      #+end_src

***** Blog post
      #+begin_src emacs-lisp
        (add-to-list 'org-roam-capture-templates
                     '("b" "blog post" plain
                       "* Reference\nYear: %^{year}\nLink: %^{link}\n\n* %?"
                       :target (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                                          ":PROPERTIES:\n:AUTHORS: %^{authors}\n:KEYWORDS: %^{keywords}\n:END:\n\n#+FILETAGS: :blog:\n#+TITLE: ${title}\n#+DATE: %U\n\n")
                       :unnarrowed t))
      #+end_src

***** therapy session
      #+begin_src emacs-lisp
        (add-to-list 'org-roam-capture-templates
                     '("s" "therapy session" entry
                       "** sessão %? - %<%Y/%m/%d>"
                       :target (file+head "20231113224353-therapy.org"
                                          "* Sessões")
                       ))
      #+end_src

***** dysfunctional thought
      #+begin_src emacs-lisp
        (add-to-list 'org-roam-capture-templates
                     '("t" "disfunctional thought" entry
                       "** [%<%Y/%m/%d %Hh%M>] "
                       :target (file+head "20231113224353-therapy.org"
                                          "* Disfunctional thought")
                       ))
      #+end_src

*** Org-roam-ui
    #+begin_src emacs-lisp
      (use-package org-roam-ui
        :defer t
        :after org-roam
        :config
        (setq org-roam-ui-sync-theme t
              org-roam-ui-follow t
              org-roam-ui-update-on-save t
              org-roam-ui-open-on-start t)
        (defun open-org-roam-ui ()
          (interactive)
          (when (not (bound-and-true-p org-roam-ui-mode))
            (org-roam-ui-mode))
          (org-roam-ui-open))
        :bind
        ("C-c b g" . open-org-roam-ui))
    #+end_src
*** Deft
    #+begin_src emacs-lisp
      (use-package deft
        :defer t
        :after org
        :bind
        ("<f8>" . deft)
        :config
        (setq deft-recursive t
              deft-use-filter-string-for-filename t
              deft-default-extension "org"
              deft-directory (file-truename "~/projects/brainiac")))

      (defun cm/deft-parse-title (file contents)
        "Parse the given FILE and CONTENTS and determine the title.
         If `deft-use-filename-as-title' is nil, the title is taken to
         be the first non-empty line of the FILE.  Else the base name of the FILE is
         used as title."
        (let ((begin (string-match "^#\\+[tT][iI][tT][lL][eE]: .*$" contents)))
          (if begin
              (string-trim (substring contents begin (match-end 0)) "#\\+[tT][iI][tT][lL][eE]: *" "[\n\t ]+")
            (deft-base-filename file))))

      (advice-add 'deft-parse-title :override #'cm/deft-parse-title)

      (setq deft-strip-summary-regexp
            (concat "\\("
                    "[\n\t]" ;; blank
                    "\\|^#\\+[[:alpha:]_]+:.*$" ;; org-mode metadata
                    "\\|^:PROPERTIES:\n\\(.+\n\\)+:END:\n"
                    "\\)"))
    #+end_src
** code blocks
*** treesit modes and code blocks
    #+begin_src emacs-lisp
      (add-to-list 'org-src-lang-modes (cons "rust" 'rust-ts))
      (add-to-list 'org-src-lang-modes (cons "go" 'go-ts))
    #+end_src
*** hide src blocks
    from https://emacs.stackexchange.com/a/31623
    #+begin_src emacs-lisp
      (with-eval-after-load 'org
        (defvar-local rasmus/org-at-src-begin -1
          "Variable that holds whether last position was a ")

        (defvar rasmus/ob-header-symbol ?☰
          "Symbol used for babel headers")

        (defun rasmus/org-prettify-src--update ()
          (let ((case-fold-search t)
                (re "^[ \t]*#\\+begin_src[ \t]+[^ \f\t\n\r\v]+[ \t]*")
                found)
            (save-excursion
              (goto-char (point-min))
              (while (re-search-forward re nil t)
                (goto-char (match-end 0))
                (let ((args (org-trim
                             (buffer-substring-no-properties (point)
                                                             (line-end-position)))))
                  (when (org-string-nw-p args)
                    (let ((new-cell (cons args rasmus/ob-header-symbol)))
                      (cl-pushnew new-cell prettify-symbols-alist :test #'equal)
                      (cl-pushnew new-cell found :test #'equal)))))
              (setq prettify-symbols-alist
                    (cl-set-difference prettify-symbols-alist
                                       (cl-set-difference
                                        (cl-remove-if-not
                                         (lambda (elm)
                                           (eq (cdr elm) rasmus/ob-header-symbol))
                                         prettify-symbols-alist)
                                        found :test #'equal)))
              ;; Clean up old font-lock-keywords.
              (font-lock-remove-keywords nil prettify-symbols--keywords)
              (setq prettify-symbols--keywords (prettify-symbols--make-keywords))
              (font-lock-add-keywords nil prettify-symbols--keywords)
              (while (re-search-forward re nil t)
                (font-lock-flush (line-beginning-position) (line-end-position))))))

        (defun rasmus/org-prettify-src ()
          "Hide src options via `prettify-symbols-mode'.

        `prettify-symbols-mode' is used because it has uncollpasing. It's
        may not be efficient."
          (let* ((case-fold-search t)
                 (at-src-block (save-excursion
                                 (beginning-of-line)
                                 (looking-at "^[ \t]*#\\+begin_src[ \t]+[^ \f\t\n\r\v]+[ \t]*"))))
            ;; Test if we moved out of a block.
            (when (or (and rasmus/org-at-src-begin
                           (not at-src-block))
                      ;; File was just opened.
                      (eq rasmus/org-at-src-begin -1))
              (rasmus/org-prettify-src--update))
            (setq rasmus/org-at-src-begin at-src-block)))

        (defun rasmus/org-prettify-symbols ()
          (mapc (apply-partially 'add-to-list 'prettify-symbols-alist)
                (cl-reduce 'append
                           (mapcar (lambda (x) (list x (cons (upcase (car x)) (cdr x))))
                                   `(("#+begin_src" . ?)
                                     ("#+end_src"   . ?)
                                     ("#+header:" . ,rasmus/ob-header-symbol)
                                     ("#+begin_quote" . ?)
                                     ("#+end_quote" . ?)
                                     ("#+begin_comment" . ?)
                                     ("#+end_comment" . ?)))))
          (turn-on-prettify-symbols-mode)
          (add-hook 'post-command-hook 'rasmus/org-prettify-src t t))

        (defun rasmus/org-prettify-src ()
          "Hide src options via `prettify-symbols-mode'.
        `prettify-symbols-mode' is used because it has uncollpasing. It's
        may not be efficient."
          (let* ((case-fold-search t)
                 (at-src-block (save-excursion
                                 (beginning-of-line)
                                 (looking-at "^[ \t]*#\\+begin_src[ \t]+[^ \f\t\n\r\v]+[ \t]*"))))
            ;; Test if we moved out of a block.
            (when (or (and rasmus/org-at-src-begin
                           (not at-src-block))
                      ;; File was just opened.
                      (eq rasmus/org-at-src-begin -1))
              (rasmus/org-prettify-src--update))
            (setq rasmus/org-at-src-begin at-src-block)))

        (add-hook 'org-mode-hook #'rasmus/org-prettify-symbols)
        )
    #+end_src
** automatically set task to DONE when all children are complete
   [[https://orgmode.org/manual/Breaking-Down-Tasks.html][doc]]
   #+begin_src emacs-lisp
     (defun org-summary-todo (n-done n-not-done)
       "Switch entry to DONE when all subentries are done, to TODO otherwise."
       (let (org-log-done org-log-states)   ; turn off logging
         (org-todo (if (= n-not-done 0) "DONE" "TODO"))))
     (add-hook 'org-after-todo-statistics-hook #'org-summary-todo)
   #+end_src
*** automatically set task DONE when all checkboxes are complete
    [[https://emacs.stackexchange.com/a/22147][source]]
    #+begin_src emacs-lisp
      (defun my/org-checkbox-todo ()
        "Switch header TODO state to DONE when all checkboxes are ticked, to TODO otherwise"
        (let ((todo-state (org-get-todo-state)) beg end)
          (unless (not todo-state)
            (save-excursion
              (org-back-to-heading t)
              (setq beg (point))
              (end-of-line)
              (setq end (point))
              (goto-char beg)
              (if (re-search-forward "\\[\\([0-9]*%\\)\\]\\|\\[\\([0-9]*\\)/\\([0-9]*\\)\\]"
                                     end t)
                  (if (match-end 1)
                      (if (equal (match-string 1) "100%")
                          (unless (string-equal todo-state "DONE")
                            (org-todo 'done))
                        (unless (string-equal todo-state "TODO")
                          (org-todo 'todo)))
                    (if (and (> (match-end 2) (match-beginning 2))
                             (equal (match-string 2) (match-string 3)))
                        (unless (string-equal todo-state "DONE")
                          (org-todo 'done))
                      (unless (string-equal todo-state "TODO")
                        (org-todo 'todo)))))))))

      (add-hook 'org-checkbox-statistics-hook 'my/org-checkbox-todo)
    #+end_src
** basic settings
   #+begin_src emacs-lisp
     (setq
      ;; adapt indentation of content to match its heading
      org-adapt-indentation nil
      org-ellipsis " ⌄ "
      org-hide-emphasis-markers t
      ;; non-nil = utf-8
      org-pretty-entities t
      org-startup-folded 'fold
      org-return-follows-link t
      ;; only needs one empty line to show an empty line when collapsed
      org-cycle-separator-lines 2
      ;; shift-select with mouse
      org-support-shift-select 'always
      ;; no help message when editing code
      org-edit-src-persistent-message nil
      line-spacing 0.5
      ;; disable a_b to be rendered as subscript, still can use a_{b} to get the same result
      org-export-with-sub-superscripts nil)

     (set-face-attribute 'org-ellipsis nil :inherit 'default :box nil)
   #+end_src
* Programming
** Utils
*** treesit-auto
    #+begin_src emacs-lisp
      (use-package treesit-auto
        :hook (after-init . global-treesit-auto-mode)
        :custom
        (treesit-auto-install 'prompt)
        :config
        (treesit-auto-add-to-auto-mode-alist 'all))
    #+end_src
*** Parens
**** Smartparens
     #+begin_src emacs-lisp
       (defun indent-between-pair (&rest _ignored)
         (newline)
         (indent-according-to-mode)
         (forward-line -1)
         (indent-according-to-mode))

       (use-package smartparens
         :hook (after-init . smartparens-global-mode)
         :bind
         ("C-M-f" . sp-forward-sexp)
         ("C-M-b" . sp-backward-sexp)
         ("C-M-n" . sp-next-sexp)
         ("C-M-p" . sp-previous-sexp)
         ("C-M-a" . sp-beginning-of-sexp)
         ("C-M-e" . sp-end-of-sexp)
         ("C-M-d" . sp-down-sexp)
         ("C-M-u" . sp-backward-up-sexp)

         ("C-M-[" . sp-wrap-square)
         ("C-M-{" . sp-wrap-curly)
         ("C-M-(" . sp-wrap-round)
         ("C-M-)" . sp-unwrap-sexp)
         ("C-M-<backspace>" . sp-backward-unwrap-sexp)

         ("C-{" . sp-backward-slurp-sexp)
         ("C-}" . sp-forward-slurp-sexp)
         ("C-M--" . sp-backward-barf-sexp)
         ("C-M-=" . sp-forward-barf-sexp)

         ("C-M-t" . sp-transpose-sexp)
         ("C-M-k" . sp-kill-sexp)
         ("C-M-w" . sp-copy-sexp)
         :config
         ;; Rust-specific pairs
         (sp-with-modes '(rust-ts-mode)
           (sp-local-pair "<" ">")
           (sp-local-pair "'" nil :actions nil))

         ;; Org-mode pairs
         (sp-with-modes '(org-mode)
           (sp-local-pair "~" "~")
           (sp-local-pair "=" "="))

         ;; Programming mode pairs with better indentation
         (sp-with-modes '(prog-mode)
           (sp-local-pair "{" nil :post-handlers '((indent-between-pair "RET")))
           (sp-local-pair "[" nil :post-handlers '((indent-between-pair "RET")))
           (sp-local-pair "(" nil :post-handlers '((indent-between-pair "RET")))))
     #+end_src
**** Show matches
     #+begin_src emacs-lisp
       (show-paren-mode 1)
       (setq show-paren-style 'mixed)
       ;; (set-face-attribute 'show-paren-match nil :foreground "#FF3377" :weight 'regular :inherit t)
     #+end_src
**** Rainbow delimiters
     #+begin_src emacs-lisp
       (use-package rainbow-delimiters
         :hook (prog-mode . rainbow-delimiters-mode))
     #+end_src
*** Git
**** Magit
     #+begin_src emacs-lisp
       (use-package magit
         :defer t
         :commands (magit-status magit-get-current-branch)
         :bind (("C-x g" . magit-status))
         :custom
         (magit-ediff-dwim-show-on-hunks t)
         (magit-format-file-function #'magit-format-file-nerd-icons)
         :hook
         (after-save . magit-after-save-refresh-status)
         :init
         (defun my-setup-magit-hooks ()
           (when (magit-git-repo-p default-directory)
             (add-hook 'after-save-hook 'magit-after-save-refresh-status nil t))))
     #+end_src

***** Magit TODOs
      #+begin_src emacs-lisp
        (use-package magit-todos
          :after magit
          :hook (magit-mode . magit-todos-mode))
      #+end_src
***** magit delta
      #+begin_src emacs-lisp
        (use-package magit-delta
          :after magit
          :commands magit-delta-mode
          :hook (magit-mode . magit-delta-mode))
      #+end_src
***** convention checks
#+begin_src emacs-lisp
  (use-package conventional-commit
    :defer t
    :straight (:host github :repo "akirak/conventional-commit.el")
    :hook
    (git-commit-mode . conventional-commit-setup))
#+end_src
**** Fringe Helper
     #+BEGIN_SRC emacs-lisp
       (use-package fringe-helper
         :defer t
         :ensure t)
     #+END_SRC

**** git gutter
     #+begin_src emacs-lisp
       (use-package git-gutter
         :hook (after-init . global-git-gutter-mode))

       (use-package git-gutter-fringe
         :after git-gutter
         :custom
         (git-gutter-fr:side 'right-fringe)
         :config

         (define-fringe-bitmap 'git-gutter-fr:added [#b11111000] nil nil '(center repeated))
         (define-fringe-bitmap 'git-gutter-fr:modified [#b11111000] nil nil '(center repeated))
         (define-fringe-bitmap 'git-gutter-fr:deleted
           [#b11000000
            #b11100000
            #b11110000
            #b11111000
            #b11111100] nil nil 'bottom)

         ;; Automatically update git-gutter on focus change
         (add-hook 'focus-in-hook #'git-gutter:update-all-windows)

         ;; Update git-gutter when saving buffer
         (add-hook 'after-save-hook 'git-gutter)

         ;; Integrate with magit for smoother operation
         (when (fboundp 'magit-mode)
           (add-hook 'magit-post-refresh-hook 'git-gutter:update-all-windows)))
     #+end_src

**** blame
     #+begin_src emacs-lisp
       (use-package blamer
         :defer 20
         :bind (("C-c i" . blamer-show-posframe-commit-info))
         :hook (prog-mode . blamer-mode)
         :custom
         (blamer-datetime-formatter ", %s ")
         (blamer-author-formatter " %s") ;; 
         (blamer-commit-formatter "")
         (blamer-idle-time 2)
         (blamer-smart-background-p t)
         (blamer-min-offset 5)
         (blamer-type 'visual) ;; only about one line
         (blamer-prettify-time-p t)
         (blamer-max-commit-message-length 30)
         (blamer-show-avatar-p t)
         (blamer-symbol-count-before-new-line 1))
     #+end_src
**** forge
     #+begin_src emacs-lisp
       (use-package forge
         :defer t
         :after magit)
     #+end_src
**** github notifications
     #+begin_src emacs-lisp
       (use-package gh-notify
         :defer t)
     #+end_src
**** review
#+begin_src emacs-lisp
  (use-package github-review
    :defer t
    :straight
    (github-review :type git :host github :repo "charignon/github-review" :files ("*.el"))
    :after forge
    :bind (("C-x r" . github-review-forge-pr-at-point)
           :map diff-mode-map ("C-c s" . my/github-review-kill-suggestion))
    :config
    ;; from github.com/anticomputer/gh-notify
    (defun my/github-review-kill-suggestion ()
      ;; kill a region of diff+ as a review suggestion template
      (interactive)
      (setq deactivate-mark t)
      (let ((s-region
             (buffer-substring-no-properties
              (region-beginning)
              (region-end))))
        (kill-new
         (format "# ```suggestion\n%s\n# ```\n"
                 (replace-regexp-in-string "^\\+" "# " s-region))))))
#+end_src
**** ediff
#+begin_src emacs-lisp
  (setq
   ediff-keep-variants nil
   ediff-make-buffers-readonly-at-startup nil
   ediff-merge-revisions-with-ancestor t
   ediff-show-clashes-only t
   ediff-split-window-function 'split-window-horizontally
   ediff-window-setup-function 'ediff-setup-windows-plain)
#+end_src
*** Region Expansion
    #+begin_src emacs-lisp
      (use-package expand-region
        :defer t
        :bind ("C-c e =" . 'er/expand-region)
        ("C-c e p" . 'er/mark-inside-pairs)
        ("C-c e P" . 'er/mark-outside-pairs)
        ("C-c e q" . 'er/mark-inside-quotes)
        ("C-c e Q" . 'er/mark-outside-quotes)
        ("C-c e m" . 'er/mark-method-call)
        ("C-c e c" . 'er/mark-comment)
        ("C-c e -" . 'er/contract-region))
    #+end_src
*** multiple-cursors
    #+begin_src emacs-lisp
      (use-package multiple-cursors
        :defer t
        :config (define-key mc/keymap (kbd "RET") nil)
        :init
        (defvar-keymap me/multiple-cursors-map
          :repeat t
          "r" #'mc/mark-all-in-region
          "l" #'mc/edit-lines
          "." #'mc/mark-next-like-this-symbol
          ">" #'mc/skip-to-next-like-this
          "," #'mc/mark-previous-like-this-symbol
          "<" #'mc/skip-to-previous-like-this)
        :bind-keymap ("C->" . me/multiple-cursors-map))
    #+end_src
*** ts-movement
    #+begin_src emacs-lisp
      (use-package ts-movement
        :defer t
        :straight (ts-movement :type git :host github :repo "haritkapadia/ts-movement" :files ("*.el*"))
        :ensure multiple-cursors
        :init
        (defvar-keymap me/ts-movement-map
                     :repeat t
                     "d" #'tsm/delete-overlay-at-point
                     "D" #'tsm/clear-overlays-of-type
                     "b" #'tsm/node-prev
                     "C-b" #'tsm/backward-overlay
                     "C-f" #'tsm/forward-overlay
                     "f" #'tsm/node-next
                     "p" #'tsm/node-parent
                     "n" #'tsm/node-child
                     "N" #'tsm/node-children
                     "s" #'tsm/node-children-of-type
                     "a" #'tsm/node-start
                     "e" #'tsm/node-end
                     "m" #'tsm/node-mark
                     "c" #'tsm/mc/mark-all-overlays)
        :bind-keymap ("C-c ." . me/ts-movement-map)
        :hook
        (bash-ts-mode . ts-movement-mode)
        (c++-ts-mode . ts-movement-mode)
        (c-ts-mode . ts-movement-mode)
        (cmake-ts-mode . ts-movement-mode)
        (csharp-ts-mode . ts-movement-mode)
        (css-ts-mode . ts-movement-mode)
        (dockerfile-ts-mode . ts-movement-mode)
        (go-mod-ts-mode . ts-movement-mode)
        (go-ts-mode . ts-movement-mode)
        (java-ts-mode . ts-movement-mode)
        (js-ts-mode . ts-movement-mode)
        (json-ts-mode . ts-movement-mode)
        (python-ts-mode . ts-movement-mode)
        (ruby-ts-mode . ts-movement-mode)
        (rust-ts-mode . ts-movement-mode)
        (toml-ts-mode . ts-movement-mode)
        (tsx-ts-mode . ts-movement-mode)
        (typescript-ts-mode . ts-movement-mode)
        (yaml-ts-mode . ts-movement-mode))
    #+end_src
*** symbol overlay
    #+begin_src emacs-lisp
      (use-package symbol-overlay)
    #+end_src
**** transient symbol overlay
#+begin_src emacs-lisp
  (use-package casual-symbol-overlay
    :bind ("M-i" . casual-symbol-overlay-tmenu))
#+end_src
*** Moving lines around
    #+begin_src emacs-lisp
      (use-package drag-stuff
        :hook (after-init . drag-stuff-global-mode)
        :config
        ;; disable it in org buffers
        (add-hook 'org-mode-hook (lambda () (drag-stuff-mode -1)))
        (drag-stuff-define-keys))
    #+end_src
*** Auto reload files
    #+begin_src emacs-lisp
      (add-hook 'after-init-hook #'global-auto-revert-mode)
      ;;(add-hook 'after-init-hook #'global-auto-revert-non-file-buffers)
    #+end_src
*** Save last cursor position
    #+begin_src emacs-lisp
      (save-place-mode 1)
    #+end_src
*** subword mode
    #+begin_src emacs-lisp
      ;; CamelCase words as individual words
      (add-hook 'prog-mode-hook 'subword-mode)
    #+end_src
*** editorconfig compat
    #+begin_src emacs-lisp
      (use-package editorconfig
        :hook (prog-mode . editorconfig-mode))
    #+end_src
*** treesitter context
    #+begin_src emacs-lisp
      (use-package treesitter-context
        :defer t
        :straight
        (:host github
         :repo "zbelial/treesitter-context.el"
         :files ("*.el"))
        :hook
        (rust-ts-mode . treesitter-context-mode)
        (js-ts-mode . treesitter-context-mode)
        (typescript-ts-mode . treesitter-context-mode)
        (tsx-ts-mode . treesitter-context-mode)
        :bind
        (:map treesitter-context-mode
              ("C-)" . treesitter-context-focus-mode))
        :custom
        (treesitter-context-frame-position 'top-right)
        (treesitter-context-frame-padding 1)
        (treesitter-context-frame-offset-x -3)
        (treesitter-context-frame-offset-y 50)
        (treesitter-context-show-context-always nil) ;; only show when the outmost parent is invisible
        (treesitter-context-frame-autohide-timeout 8)
        (treesitter-context-show-line-number t)
        (treesitter-context-frame-min-height 1)
        (treesitter-context-border-width 2)
        (treesitter-context-frame-min-width 1)
        (treesitter-context-fold-show-fringe-marks nil)
        (treesitter-context-frame-font-fraction 0.85)
        (treesitter-context-border-color (face-attribute 'mode-line :background))
        (treesitter-context-background-color (face-attribute 'default :background)))
    #+end_src
*** treesit-fold
#+begin_src emacs-lisp
  (use-package treesit-fold
    :hook (after-init . global-treesit-fold-mode)
    :straight (:host github :repo "emacs-tree-sitter/treesit-fold")
    :custom
    (treesit-fold-summary-show nil)
    :bind (:map treesit-fold-mode-map
                (("C-{" . treesit-fold-toggle)
                 ("C-*" . treesit-fold-open-all)
                 ("C-}" . treesit-fold-close-all))))
#+end_src
*** better regexes
#+begin_src emacs-lisp
  (use-package visual-regexp
    :defer t)
  (use-package visual-regexp-steroids
    :defer t
    :bind
    (:map me/multiple-cursors-map
          ("C-> r"))
    ("C-r" . vr/isearch-backward)
    ("C-s" . vr/isearch-forward)
    ("C-M-%" . vr/replace))
#+end_src
*** better jumper
#+begin_src emacs-lisp
  (use-package better-jumper
    :init
    (defvar-keymap me/better-jumper-map
      :repeat t
      "<left>" #'better-jumper-jump-forward
      "<right>" #'better-jumper-jump-backward
      "." #'better-jumper-set-jump)
    :bind-keymap ("C-c j" . me/better-jumper-map)
    :hook (prog-mode turn-on-better-jumper-mode))
#+end_src
** Languages specifics
*** Rust
**** Rust mode
     #+begin_src emacs-lisp
       (use-package rust-ts-mode
         :defer t)

       (defun my/rust-eglot-setup ()
         "Set up rust-analyzer initialization options for Eglot."
         (setq-local eglot-workspace-configuration
                     '((:rust-analyzer
                        (:lruCapacity 1920) ; (* 15 128)
                        (:procMacro (:enable . t))
                        (:lens
                         (:references
                          (:adt (:enable . t))
                          (:enumVariant (:enable . t))
                          (:method (:enable . t))
                          (:trait (:enable . t))))
                        (:completion (:autoimport (:enable . t)))
                        (:inlayHints
                         (:bindingModeHints (:enable . t))
                         (:chainingHints (:enable . t))
                         (:closingBraceHints (:minLines . 0))
                         (:closureCaptureHints (:enable . t))
                         (:closureReturnTypeHints (:enable . "with_block"))
                         (:discriminantHints (:enable . "always"))
                         (:expressionAdjustmentHints
                          (:enable . "always")
                          (:mode . "prefer_postfix"))
                         (:implicitDrops (:enable . t))
                         (:lifetimeElisionHints
                          (:enable . "always")
                          (:useParameterNames . t))
                         (:maxLen . 25)
                         (:parameterHints (:enable . t))
                         (:reborrowHints (:enable . "always"))
                         (:displayClosureReturnTypeHints . t)
                         ;; (:hideClosureInitialization . t)
                         ;; (:hideNamedConstructor . t)
                         )))))
       (add-hook 'rust-ts-mode-hook #'my/rust-eglot-setup)
     #+end_src
**** special queries
***** special treatment for ~todo!~ macro
let's make it more visible
#+begin_src emacs-lisp
  (defface my-rust-unwrap-face
    '((t (:inherit error
                :weight bold
                :foreground "#AD3E3E")))
    "Face for Rust .unwrap() calls")

  (defface my-rust-macro-face
    '((t (:inherit font-lock-function-call-face
                   :slant italic
                   :width expanded
                   :underline t)))
    "Face for Rust todo! macro calls")

  (defface my-rust-attribute-face
    '((t (:inherit font-lock-preprocessor-face
                   :weight light
                   :width expanded
                   :slant oblique
                   :foreground "#7e57c2")))
    "Face for Rust attribute items")

  (defun my-rust-ts-mode-highlighting ()
    "Apply custom tree-sitter highlights for Rust mode."
    (setq-local
     treesit-font-lock-settings
     (append
      treesit-font-lock-settings
      ;; Highlight .unwrap() calls
      (treesit-font-lock-rules
       :language 'rust
       :feature 'unwrap-call
       :override t
       '(((field_expression
           field: (field_identifier) @my-rust-unwrap-face)
          (:match "^unwrap$" @my-rust-unwrap-face))))

      ;; Highlight todo!() macro
      (treesit-font-lock-rules
       :language 'rust
       :feature 'todo-macro
       :override t
       '(((macro_invocation
           (identifier) @my-rust-macro-face)
          (:match "^todo$" @my-rust-macro-face))))

      ;; Highlight #[attribute] items
      (treesit-font-lock-rules
       :language 'rust
       :feature 'attribute-items
       :override t
       '((attribute_item) @my-rust-attribute-face)))))

  (add-hook 'rust-ts-mode-hook #'my-rust-ts-mode-highlighting)
#+end_src
**** Better cargo integration
     #+begin_src emacs-lisp
       (use-package cargo-transient
         :defer t
         :after rust-ts-mode
         :bind (:map rust-ts-mode-map
                     ("C-c C-c t" . cargo-transient)
                     ("C-c C-c c" . cargo-transient-check)
                     ("C-c C-c l" . cargo-transient-clippy)
                     ("C-c C-c f" . cargo-transient-clippy-fix)
                     ("C-c C-c k" . cargo-transient-clippy-test)
                     ("C-c C-c r" . cargo-transient-run)))
     #+end_src
**** COMMENT LSP config
     #+begin_src emacs-lisp
       (setq lsp-rust-analyzer-lru-capacity (* 15 128)
             lsp-rust-analyzer-binding-mode-hints t
             lsp-rust-analyzer-check-all-targets t
             lsp-rust-analyzer-closing-brace-hints-min-lines 0
             lsp-rust-analyzer-closure-capture-hints t
             lsp-rust-analyzer-closure-return-type-hints "with_block"
             lsp-rust-analyzer-diagnostics-enable-experimental t
             lsp-rust-analyzer-discriminants-hints "always" ;; "fieldless"
             lsp-rust-analyzer-display-chaining-hints t
             lsp-rust-analyzer-display-closure-return-type-hints t
             lsp-rust-analyzer-display-lifetime-elision-hints-enable "always"
             lsp-rust-analyzer-display-lifetime-elision-hints-use-parameter-names t

             lsp-rust-analyzer-display-parameter-hints t
             lsp-rust-analyzer-display-reborrow-hints "always"
             lsp-rust-analyzer-expression-adjustment-hints "always"
             lsp-rust-analyzer-hide-closure-initialization t
             lsp-rust-analyzer-hide-named-constructor t
             lsp-rust-analyzer-implicit-drops t
             lsp-rust-analyzer-max-inlay-hint-length 25

             lsp-rust-analyzer-proc-macro-enable t
             lsp-rust-analyzer-lens-references-adt-enable t
             lsp-rust-analyzer-lens-references-method-enable t

             lsp-rust-analyzer-lens-references-trait-enable t
             lsp-rust-analyzer-lens-references-enum-variant-enable t
             lsp-rust-analyzer-server-display-inlay-hints t
             lsp-rust-analyzer-completion-auto-import-enable t
             lsp-rust-analyzer-expression-adjustment-hints-mode "prefer_postfix"

             lsp-semantic-tokens-enable t)
     #+end_src
**** When creating news language bugs
     [[https://rustc-dev-guide.rust-lang.org/building/suggested.html#configuring-rust-analyzer-for-rustc][Configuring rust-analyzer for rustc]]
     #+begin_src emacs-lisp
       ;; (setq
       ;;  lsp-rust-analyzer-rustfmt-override-command ["./build/x86_64-unknown-linux-gnu/stage0/bin/rustfmt", "--edition=2021"]
       ;;  lsp-rust-analyzer-cargo-run-build-scripts t
       ;;  lsp-rust-analyzer-rustc-source "./Cargo.toml"
       ;;  lsp-rust-analyzer-proc-macro-enable t)
     #+end_src
*** hyprlang
#+begin_src emacs-lisp
  (use-package hyprlang-ts-mode
    :defer t
    :init
    (add-to-list 'treesit-language-source-alist
          '(hyprlang "https://github.com/tree-sitter-grammars/tree-sitter-hyprlang"))
    :custom
    (hyprlang-ts-mode-indent-offset 4))
#+end_src
*** COMMENT Unison
**** Unison mode
     #+begin_src emacs-lisp
       (use-package unison-ts-mode
         :defer t
         :straight (unison-ts-mode :type git :host github :repo "fmguerreiro/unison-ts-mode" :files ("*.el")))
     #+end_src
***** COMMENT grammar
      #+begin_src emacs-lisp
        (push '((unison "https://github.com/fmguerreiro/tree-sitter-unison-kylegoetz" "build/include-parser-in-src-control"))
              treesit-language-source-alist)
      #+end_src
*** COMMENT Elixir
**** Elixir mode
     #+begin_src emacs-lisp
       (use-package elixir-mode
         :defer t
         :hook (elixir-mode . lsp)
         :init (add-to-list 'exec-path "~/.elixir_ls/"))
     #+end_src
**** Elixir snippets
     #+begin_src emacs-lisp
       (use-package elixir-yasnippets
         :defer t)
     #+end_src
**** Elixir flycheck
     #+begin_src emacs-lisp
       (use-package flycheck-elixir
         :defer t)
     #+end_src

*** COMMENT Haskell
**** LSP
     #+begin_src emacs-lisp
       (use-package lsp-haskell
         :defer t
         :config
         (setq lsp-haskell-server-path "haskell-language-server-wrapper"
               lsp-haskell-plugin-semantic-tokens-global-on nil)
         :hook (haskell-mode . lsp))
     #+end_src

*** COMMENT OCaml
**** ocaml mode
     #+begin_src emacs-lisp
       (use-package tuareg-mode
         :defer t
         :hook (tuareg-mode . lsp))
     #+end_src
**** dune mode
     #+begin_src emacs-lisp
       (use-package dune
         :defer t)
     #+end_src

*** COMMENT TypeScript
    #+begin_src emacs-lisp
      (add-hook 'js-ts-mode-hook #'lsp)
      (add-hook 'typescript-ts-mode-hook #'lsp)
      (add-hook 'tsx-ts-mode-hook #'lsp)
    #+end_src

*** COMMENT Scala3

**** lsp
#+begin_src emacs-lisp
  (use-package lsp-metals
    :defer t
    :hook (scala-mode . lsp)
    :custom
    (lsp-metals-enable-semantic-highlighting t))
#+end_src

**** sbt-mode
#+begin_src emacs-lisp
  (use-package sbt-mode
    :defer t
    :commands sbt-start sbt-command
    :config
    ;; WORKAROUND: https://github.com/ensime/emacs-sbt-mode/issues/31
    ;; allows using SPACE when in the minibuffer
    (substitute-key-definition
     'minibuffer-complete-word
     'self-insert-command
     minibuffer-local-completion-map)
    ;; sbt-supershell kills sbt-mode:  https://github.com/hvesalai/emacs-sbt-mode/issues/152
    (setq sbt:program-options '("-Dsbt.supershell=false")))
#+end_src

**** COMMENT treesitter
#+begin_src emacs-lisp
  (use-package scala-ts-mode
    :hook (scala-ts-mode . lsp))
#+end_src

*** markdown
#+begin_src emacs-lisp
  (use-package markdown-ts-mode
    :mode ("\\.md\\'" . markdown-ts-mode)
    :defer t
    :config
    (add-to-list 'treesit-language-source-alist '(markdown "https://github.com/tree-sitter-grammars/tree-sitter-markdown" "split_parser" "tree-sitter-markdown/src"))
    (add-to-list 'treesit-language-source-alist '(markdown-inline "https://github.com/tree-sitter-grammars/tree-sitter-markdown" "split_parser" "tree-sitter-markdown-inline/src")))
#+end_src

*** just files
#+begin_src emacs-lisp
  (use-package just-ts-mode
    :defer t)
#+end_src

* Utils
** Easy increase/decrease font size
   #+begin_src emacs-lisp
     (global-set-key (kbd "C-+") #'text-scale-increase)
     (global-set-key (kbd "C--") #'text-scale-decrease)
   #+end_src
** Kill current buffer
   #+begin_src emacs-lisp
     (global-set-key (kbd "C-x k") (lambda () (interactive) (kill-buffer (current-buffer))))
   #+end_src

** Use y-or-n
   #+begin_src emacs-lisp
     (defalias 'yes-or-no-p 'y-or-n-p)
   #+end_src

** Use spaces
   #+begin_src emacs-lisp
     (setq-default indent-tabs-mode nil)
     (setq-default tab-width 4)

     (defun consoli/infer-indentation-style ()
       "If our source file use tabs, we use tabs, if spaces, spaces.
         And if neither, we use the current indent-tabs-mode"
       (let ((space-count (how-many "^ " (point-min) (point-max)))
             (tab-count (how-many "^\t" (point-min) (point-max))))
         (if (> space-count tab-count) (setq indent-tabs-mode nil))
         (if (> tab-count space-count) (setq indent-tabs-mode t))))
     (add-hook 'prog-mode-hook #'consoli/infer-indentation-style)
   #+end_src
** Don't freeze
   #+begin_src emacs-lisp
     (defun suspend-if-in-shell ()
       "suspend process if the instance is not running in GUI"
       (progn
         (when (not (display-graphic-p))
           (suspend-emacs))))
     (global-set-key (kbd "C-z") (lambda () (interactive) (suspend-if-in-shell)))
   #+end_src
** Preserve screen position
    #+begin_src emacs-lisp
      (setq scroll-preserve-screen-position t
            scroll-conservatively 101
            fast-but-imprecise-scrolling t
            redisplay-dont-pause 1
            jit-lock-defer-time 0)
    #+end_src
** ultra scroll
#+begin_src emacs-lisp
  (use-package ultra-scroll
    :straight (:host github :repo "jdtsmith/ultra-scroll" :files ("*.el"))
    :custom
    (scroll-conservatively 101) ; important!
    (scroll-margin 0)
    :hook (after-init . ultra-scroll-mode))
#+end_src
** Backup files
*** Change backup directory
    By default, emacs saves the ~backup~~ files in the same directory the file is.
    #+begin_src emacs-lisp
      (setq backup-directory-alist '(("." . "~/.emacs.d/backup/per-save"))
            auto-save-file-name-transforms '((".*" "~/.emacs.d/backup/auto-saves/")))
    #+end_src
*** More backup files
    #+begin_src emacs-lisp
      (setq delete-old-versions t
            ;; number of new versions of a file to kept
            kept-new-versions 1
            ;; number of old version to kept
            kept-old-versions 2
            ;; numeric version control
            version-control t
            ;; copy files, dont rename them
            backup-by-copying t)
    #+end_src
*** Auto-save files
    Auto-save files are temporary files that Emacs creates until a file is saved.
    Emacs auto-saves whenever it crashes, after ~N~ keystrokes and after a timeout.
    #+begin_src emacs-lisp
      (setq auto-save-timeout 15 ;; seconds
            auto-save-interval 200)
    #+end_src
** lockfiles
   #+begin_src emacs-lisp
     (setq create-lockfiles nil)
   #+end_src
** Do what i mean
   #+begin_src emacs-lisp
     (global-set-key (kbd "M-u") 'upcase-dwim)
     (global-set-key (kbd "M-l") 'downcase-dwim)
     (global-set-key (kbd "M-c") 'capitalize-dwim)
   #+end_src
** A Collection of Ridiculous Useful eXtensions
   #+begin_src emacs-lisp
     (use-package crux
       :bind ([remap kill-line] . crux-smart-kill-line)
       ([remap kill-whole-line] . crux-kill-whole-line)
       ("C-a" . crux-move-beginning-of-line)
       ("C-c d" . crux-duplicate-current-line-or-region)
       ("C-c M-d" . crux-duplicate-and-comment-current-line-or-region))
       #+end_src
** Open lines around
   #+begin_src emacs-lisp
     (defun consoli/insert-new-line-bellow ()
       (interactive)
       (let ((current-point (point)))
         (move-end-of-line 1)
         (open-line 1)
         (goto-char current-point)))
     (global-set-key (kbd "C-S-<down>") 'consoli/insert-new-line-bellow)

     (defun consoli/insert-new-line-above ()
       (interactive)
       (let ((current-point (point)))
         (move-beginning-of-line 1)
         (newline-and-indent)
         (indent-according-to-mode)
         (goto-char current-point)
         (forward-char)))
     (global-set-key (kbd "C-S-<up>") 'consoli/insert-new-line-above)
   #+end_src
** new line follow indentation
   #+begin_src emacs-lisp
     (global-set-key (kbd "RET") 'indent-new-comment-line)
   #+end_src
** Hide unwanted buffers when cycling
   #+begin_src emacs-lisp
     (set-frame-parameter (selected-frame) 'buffer-predicate #'buffer-file-name)
   #+end_src

** no bell
   #+begin_src emacs-lisp
     (setq ring-bell-function 'ignore)
   #+end_src
** Spell checking
*** Jinx
    #+begin_src emacs-lisp
      (use-package jinx
        :hook (emacs-startup . global-jinx-mode)
        :config
        (setq jinx-languages "en_UK en_US pt_BR")

        ;; `M-$` correct the word at point
        :bind ([remap ispell-word] . jinx-correct)
        ("M-|" . jinx-correct-nearest))
    #+end_src
** Ccedilla in emacs
   #+begin_src emacs-lisp
     (global-set-key (kbd "ć") (lambda () (interactive) (insert "ç")))
     (global-set-key (kbd "Ć") (lambda () (interactive) (insert "Ç")))
   #+end_src
** hide commands in M-x which do not apply to the current mode
   #+begin_src emacs-lisp
     (setq read-extended-command-predicate #'command-completion-default-include-p)
   #+end_src
** tab always complete
   #+begin_src emacs-lisp
     (setq tab-always-indent 'complete)

     ;; for emacs 30 or newer
     (setq text-mode-ispell-word-completion nil)

     ;; prefer cape-dict
     ;; (text-mode-ispell-word-completion nil)
   #+end_src
** dim marked region when using kill ring
   Taken from: https://www.youtube.com/watch?v=oQ9JE9kRwG8
   #+begin_src emacs-lisp
     (defun my/pulse-current-region (&rest _)
       "Pulse the current implicit or active region"
       (if mark-active
           (pulse-momentary-highlight-region (region-beginning) (region-end))
         (pulse-momentary-highlight-region (mark) (point))))

     (setq pulse-delay 0.03
           pulse-iterations 13)

     (advice-add #'kill-ring-save :before #'my/pulse-current-region)
   #+end_src
** undo tree
#+begin_src emacs-lisp
  (use-package undo-tree
    :hook (after-init . global-undo-tree-mode)
    :config
    (setq undo-tree-history-directory-alist '(("." . "~/.emacs.d/undo"))
          undo-tree-visualizer-lazy-drawing 10))
#+end_src
** rainbow mode
#+begin_src emacs-lisp
  (use-package colorful-mode
    :hook (prog-mode text-mode))
#+end_src
** annotate
#+begin_src  emacs-lisp
  (use-package annotate
    :config
    (setq annotate-annotation-column 25
          annotate-use-messages nil
          annotate-use-echo-area nil
          annotate-highlight-faces '((:underline "#c4addd")
                                     (:underline "#d1c0ec")
                                     (:underline "#8d77a8"))
          annotate-annotation-text-faces '((:inherit 'font-lock-comment-face
                                                     :slant italic
                                                     :family alternative-programming-font)
                                           (:inherit 'font-lock-comment-face
                                                     :slant italic
                                                     :family alternative-programming-font)
                                           (:inherit 'font-lock-comment-face
                                                     :slant italic
                                                     :family alternative-programming-font)))
    :hook (prog-mode . annotate-mode)
    :init
    (setq annotate-mode-map (make-sparse-keymap))
    (define-prefix-command 'annotate-command-prefix)
    (define-key annotate-mode-map (kbd "C-c C-a") 'annotate-command-prefix)
    :bind
    (:map annotate-command-prefix
          ("n" . annotate-toggle-annotation-text)
          ("a" . annotate-annotate)
          ("d" . annotate-delete-annotation)
          ("s" . annotate-show-annotation-summary)
          ("c" . annotate-change-annotation-colors)
          ("p" . annotate-change-annotation-position)
          ("<left>" . annotate-goto-next-annotation)
          ("<right>" . annotate-goto-previous-annotation)))
#+end_src
** mouse
#+begin_src emacs-lisp
  (xterm-mouse-mode t)
#+end_src
** exec path
#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :if (and (eq system-type 'gnu/linux) (display-graphic-p))
    :custom
    (exec-path-from-shell-variables
     '("PATH" "MANPATH" "XDG_DATA_DIRS" "XDG_CONFIG_DIRS"
       "CARGO_HOME" "RUSTUP_HOME"
       "GOPATH" "GOROOT"
       "PYTHONPATH"
       "NODE_PATH"))
    (exec-path-from-shell-check-startup-files nil)
    (exec-path-from-shell-shell-name (getenv "SHELL"))
    :config
    (exec-path-from-shell-initialize))
#+end_src
** Delete selection
   #+begin_src emacs-lisp
     (pending-delete-mode t)
     (delete-selection-mode t)
   #+end_src
** always saves bookmarks
#+begin_src emacs-lisp
  (setq bookmark-save-flag 1)
#+end_src
** ibuffer
#+begin_src emacs-lisp
  (setq ibuffer-expert t)
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src
** copy/paste integration on terminal
#+begin_src emacs-lisp
  (setq xterm-extra-capabilities '(getSelection setSelection modifyOtherKeys))
#+end_src
